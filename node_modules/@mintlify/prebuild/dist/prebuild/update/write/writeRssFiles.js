import { stringifyTree, findAndRemoveImports } from '@mintlify/common';
import fse from 'fs-extra';
import { getGitBlame } from '../git/getGitBlame.js';
import { docsConfigToRss } from '../rss/docsConfigToRss.js';
import { pageToRss } from '../rss/pageToRss.js';
import { pathToRss } from '../rss/pathToRss.js';
const extractSnippets = async (tree, allSnippets) => {
    if (!allSnippets || allSnippets.length === 0) {
        return [];
    }
    const clonedTree = structuredClone(tree);
    const { importMap } = await findAndRemoveImports(clonedTree);
    if (Object.keys(importMap).length === 0) {
        return [];
    }
    const referencedSnippets = [];
    for (const importPath of Object.keys(importMap)) {
        const normalizedImportPath = importPath.startsWith('/') ? importPath.slice(1) : importPath;
        const snippet = allSnippets.find((s) => s.filename === normalizedImportPath);
        if (snippet) {
            referencedSnippets.push({
                path: snippet.filename,
                content: stringifyTree(snippet.tree),
            });
        }
    }
    return referencedSnippets;
};
export const writeRssFiles = async (docsConfig, rssPages, contentDirectoryPath, allSnippets) => {
    const { orgName, orgDescription } = docsConfigToRss(docsConfig);
    const rssTargetPath = 'src/_props/rssFiles.json';
    const rssItemsPromises = rssPages.map(async (page) => {
        const { targetPath, sourcePath, tree, snippets: preExtractedSnippets } = page;
        const { title, description } = pageToRss(tree);
        const rssPath = pathToRss(targetPath);
        const content = stringifyTree(tree);
        let lineBlame = {};
        try {
            lineBlame = await getGitBlame(sourcePath, contentDirectoryPath);
        }
        catch (error) { }
        let snippets;
        if (preExtractedSnippets && preExtractedSnippets.length > 0) {
            snippets = preExtractedSnippets.map((s) => ({
                path: s.filename,
                content: stringifyTree(s.tree),
                importNames: s.importNames,
            }));
        }
        else {
            snippets = await extractSnippets(tree, allSnippets);
        }
        const filePath = sourcePath.substring(contentDirectoryPath.length + 1);
        const rssFileV4 = {
            version: 'v4',
            rssPath,
            orgName,
            orgDescription,
            title,
            description,
            filePath,
            content,
            lineBlame,
            snippets: snippets.length > 0 ? snippets : undefined,
        };
        return rssFileV4;
    });
    const rssItemsToSave = await Promise.all(rssItemsPromises);
    await fse.remove(rssTargetPath);
    await fse.outputFile(rssTargetPath, JSON.stringify(rssItemsToSave, null, 2), {
        flag: 'w',
    });
};
