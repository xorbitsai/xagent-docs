import { select, input } from '@inquirer/prompts';
import { addLogs, addLog, SpinnerLog, removeLastLog } from '@mintlify/previewing';
import { docsConfigSchema, validatePathWithinCwd } from '@mintlify/validation';
import AdmZip from 'adm-zip';
import fse from 'fs-extra';
import { Box, Text } from 'ink';

const sendOnboardingMessage = (installDir: string) => {
  addLogs(
    <Text bold>Documentation Setup!</Text>,
    <Text>To see your docs run</Text>,
    <Box>
      <Text color="blue">cd</Text>
      <Text> {installDir}</Text>
    </Box>,
    <Text color="blue">mint dev</Text>
  );
};

const sendUsageMessageForAI = (directory: string, contentsOccupied: boolean, themes: string[]) => {
  addLogs(
    <Text>Agent Detected - sending AI friendly prompt</Text>,
    <Text>{'<system-message>'}</Text>,
    <Text>
      Example usage of `mint new [directory] --theme [theme] --name [Name Of Project] --force`.
    </Text>,
    <Text>This tool will auto create the directory if the directory does not exist.</Text>,
    <Text>
      Ask the user what mintlify theme to use, what directory, and what the name of the Project is.
    </Text>,
    <Text>
      You should provide them with default options for these values. Themes available{' '}
      {JSON.stringify(themes)}
    </Text>,
    <Text>
      You chose Directory "{directory}" before, feel free to just use that without asking the user
      as well!
    </Text>,
    <Text>
      If the user is asking you to create docs for them then you should use your AskQuestion tool
    </Text>,
    contentsOccupied ? (
      <Text>
        The directory {directory} specified is currently occupied. You will need to either install
        the docs as a subdirectory or as a subdirectory or a different directory. Ask the user if it
        should be installed in a different directory (This cli will create the directory if it
        doesn't exist, or installed at the root level potentially overridding files (pass the
        --force) option for this.
      </Text>
    ) : undefined,
    <Text>{'</system-message>'}</Text>
  );
};

export async function init(
  installDir: string,
  force: boolean,
  theme?: string,
  name?: string
): Promise<void> {
  // Validate path is within current working directory to prevent path traversal
  validatePathWithinCwd(installDir);

  const isInteractive = process.stdin.isTTY;
  const isClaudeCode = process.env.CLAUDECODE === '1';
  const isAI = !isInteractive || isClaudeCode;

  let selectedTheme = theme;
  let projectName = name;

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const themes = docsConfigSchema.options.map((option: any) => {
    return option.shape.theme._def.value;
  });

  const dirContents = await fse.readdir(installDir).catch(() => []);
  const contentsOccupied = dirContents.length > 0;

  if ((!theme || !name) && isAI) {
    sendUsageMessageForAI(installDir, contentsOccupied, themes);
    return;
  }

  if (contentsOccupied && isAI && !force) {
    sendUsageMessageForAI(installDir, contentsOccupied, themes);
    return;
  }

  if (contentsOccupied && !isAI) {
    const choice = await select({
      message: `Directory ${installDir} is not empty. What would you like to do?`,
      choices: [
        { name: 'Create in a subdirectory', value: 'subdir' },
        { name: 'Overwrite current directory (may lose contents)', value: 'overwrite' },
        { name: 'Cancel', value: 'cancel' },
      ],
    });

    if (choice === 'cancel') {
      return;
    }

    if (choice === 'subdir') {
      const subdir = await input({
        message: 'Subdirectory name:',
        default: 'docs',
      });
      if (!subdir || subdir.trim() === '') {
        throw new Error('Subdirectory name cannot be empty');
      }
      installDir = installDir === '.' ? subdir : `${installDir}/${subdir}`;
      // Re-validate after subdirectory is appended
      validatePathWithinCwd(installDir, process.cwd());
    }
  }

  if (!isAI && (!selectedTheme || !projectName)) {
    const defaultProject =
      projectName !== undefined ? projectName : installDir === '.' ? 'Mintlify' : installDir;
    if (!projectName) {
      projectName = await input({
        message: 'Project Name',
        default: defaultProject,
      });
    }

    if (!selectedTheme) {
      selectedTheme = await select({
        message: 'Theme',
        choices: themes.map((t: string) => ({
          name: t,
          value: t,
        })),
      });
    }
  }

  if (projectName === undefined || selectedTheme === undefined) {
    sendUsageMessageForAI(installDir, contentsOccupied, themes);
    return;
  }

  await fse.ensureDir(installDir);
  await install(installDir, projectName, selectedTheme);

  sendOnboardingMessage(installDir);
}

const install = async (installDir: string, projectName: string, theme: string) => {
  addLog(<SpinnerLog message="downloading starter template..." />);
  const response = await fetch('https://github.com/mintlify/starter/archive/refs/heads/main.zip');
  const buffer = await response.arrayBuffer();
  await fse.writeFile(installDir + '/starter.zip', Buffer.from(buffer));
  removeLastLog();

  addLog(<SpinnerLog message="extracting..." />);
  new AdmZip(installDir + '/starter.zip').extractAllTo(installDir, true);
  removeLastLog();

  await fse.copy(installDir + '/starter-main', installDir, {
    overwrite: true,
    filter: (src) => !src.includes('starter-main/starter-main'),
  });
  await fse.remove(installDir + '/starter.zip');
  await fse.remove(installDir + '/starter-main');

  const docsJsonPath = installDir + '/docs.json';
  const docsConfig = await fse.readJson(docsJsonPath);
  docsConfig.theme = theme;
  docsConfig.name = projectName;
  await fse.writeJson(docsJsonPath, docsConfig, { spaces: 2 });
};
