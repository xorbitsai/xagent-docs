import { validate, getOpenApiDocumentFromUrl, isAllowedLocalSchemaUrl } from '@mintlify/common';
import { getBrokenInternalLinks, renameFilesAndUpdateLinksInContent } from '@mintlify/link-rot';
import {
  addLog,
  dev,
  validateBuild,
  ErrorLog,
  SpinnerLog,
  SuccessLog,
  Logs,
  clearLogs,
  BrokenLinksLog,
  WarningLog,
} from '@mintlify/previewing';
import { render, Text } from 'ink';
import path from 'path';
import yargs from 'yargs';
import { hideBin } from 'yargs/helpers';

import { accessibilityCheck } from './accessibilityCheck.js';
import {
  checkPort,
  checkForMintJson,
  checkNodeVersion,
  upgradeConfig,
  checkForDocsJson,
  getVersions,
  suppressConsoleWarnings,
  terminate,
  readLocalOpenApiFile,
} from './helpers.js';
import { init } from './init.js';
import { mdxLinter } from './mdxLinter.js';
import { migrateMdx } from './migrateMdx.js';
import { update } from './update.js';

export const cli = ({ packageName = 'mint' }: { packageName?: string }) => {
  render(<Logs />);

  return (
    yargs(hideBin(process.argv))
      .scriptName(packageName)
      .middleware(checkNodeVersion)
      .middleware(suppressConsoleWarnings)
      .command(
        'dev',
        'initialize a local preview environment',
        (yargs) =>
          yargs
            .option('open', {
              type: 'boolean',
              default: true,
              description: 'open a local preview in the browser',
            })
            .option('local-schema', {
              type: 'boolean',
              default: false,
              hidden: true,
              description:
                'use a locally hosted schema file (note: only https protocol is supported in production)',
            })
            .option('client-version', {
              type: 'string',
              hidden: true,
              description: 'the version of the client to use for cli testing',
            })
            .option('local-client-version', {
              type: 'string',
              hidden: true,
              description: 'path to local client repo to symlink for development',
            })
            .option('groups', {
              type: 'array',
              description: 'Mock user groups for local development and testing',
              example: '--groups admin user',
            })
            .option('disable-openapi', {
              type: 'boolean',
              default: false,
              description: 'Disable OpenAPI file generation',
            })
            .usage('usage: mintlify dev [options]')
            .example('mintlify dev', 'run with default settings (opens in browser)')
            .example('mintlify dev --no-open', 'run without opening in browser'),
        async (argv) => {
          let nodeVersionString = process.version;
          if (nodeVersionString.charAt(0) === 'v') {
            nodeVersionString = nodeVersionString.slice(1);
          }
          const versionArr = nodeVersionString.split('.');
          const majorVersion = parseInt(versionArr[0]!, 10);
          const minorVersion = parseInt(versionArr[1]!, 10);

          if (majorVersion >= 25) {
            addLog(
              <ErrorLog message="mint dev is not supported on node versions 25+. Please downgrade to an LTS node version." />
            );
            await terminate(1);
          }

          if (majorVersion < 20 || (majorVersion === 20 && minorVersion < 17)) {
            addLog(
              <ErrorLog message="mint dev is not supported on node versions below 20.17 Please upgrade to an LTS node version." />
            );
            await terminate(1);
          }

          const port = await checkPort(argv);
          const { cli: cliVersion } = getVersions();
          if (port != undefined) {
            await dev({
              ...argv,
              port,
              packageName,
              cliVersion,
            });
          } else {
            addLog(<ErrorLog message="no available port found" />);
            await terminate(1);
          }
        }
      )
      .command(
        'validate',
        'validate the documentation build (strict mode, exits on warnings or errors)',
        (yargs) =>
          yargs
            .option('local-schema', {
              type: 'boolean',
              default: false,
              hidden: true,
              description: 'use a locally hosted schema file',
            })
            .option('client-version', {
              type: 'string',
              hidden: true,
              description: 'the version of the client to use for cli testing',
            })
            .option('groups', {
              type: 'array',
              description: 'Mock user groups for validation',
            })
            .option('disable-openapi', {
              type: 'boolean',
              default: false,
              description: 'Disable OpenAPI file generation',
            })
            .usage('usage: mintlify validate [options]')
            .example('mintlify validate', 'validate the build'),
        async (argv) => {
          const { cli: cliVersion } = getVersions();
          await validateBuild({
            ...argv,
            packageName,
            cliVersion,
          });
        }
      )
      .command(
        'openapi-check <filename>',
        'check if an OpenAPI spec is valid',
        (yargs) =>
          yargs
            .positional('filename', {
              describe:
                'the filename of the OpenAPI spec (e.g. ./openapi.yaml) or the URL to the OpenAPI spec (e.g. https://petstore3.swagger.io/api/v3/openapi.json)',
              type: 'string',
              demandOption: true,
            })
            .option('local-schema', {
              type: 'boolean',
              default: false,
              description:
                'use a locally hosted schema file (note: only https protocol is supported in production)',
            }),
        async ({ filename, 'local-schema': localSchema }) => {
          try {
            if (isAllowedLocalSchemaUrl(filename, localSchema)) {
              await getOpenApiDocumentFromUrl(filename);
              addLog(<SuccessLog message="OpenAPI definition is valid." />);
              await terminate(0);
            }

            if (filename.startsWith('http://') && !localSchema) {
              addLog(
                <WarningLog message="include the --local-schema flag to check locally hosted OpenAPI files" />
              );
              addLog(<WarningLog message="only https protocol is supported in production" />);
              await terminate(0);
            }

            const document = await readLocalOpenApiFile(filename);

            if (!document) {
              throw new Error(
                'failed to parse OpenAPI spec: could not parse file correctly, please check for any syntax errors.'
              );
            }
            await validate(document);
            addLog(<SuccessLog message="OpenAPI definition is valid." />);
          } catch (err) {
            if (err && typeof err === 'object' && 'code' in err && err.code === 'ENOENT') {
              addLog(
                <ErrorLog message={`file not found, please check the path provided: ${filename}`} />
              );
            } else {
              addLog(<ErrorLog message={err instanceof Error ? err.message : 'unknown error'} />);
            }
            await terminate(1);
          }

          await terminate(0);
        }
      )
      .command(
        'broken-links',
        'check for invalid internal links',
        () => undefined,
        async () => {
          const hasMintJson = await checkForMintJson();
          if (!hasMintJson) {
            await checkForDocsJson();
          }

          addLog(<SpinnerLog message="checking for broken links..." />);
          try {
            const brokenLinks = await getBrokenInternalLinks();
            if (brokenLinks.length === 0) {
              clearLogs();
              addLog(<SuccessLog message="no broken links found" />);
              await terminate(0);
            }

            const brokenLinksByFile: Record<string, string[]> = {};
            brokenLinks.forEach((mdxPath) => {
              const filename = path.join(mdxPath.relativeDir, mdxPath.filename);
              const brokenLinksForFile = brokenLinksByFile[filename];
              if (brokenLinksForFile) {
                brokenLinksForFile.push(mdxPath.originalPath);
              } else {
                brokenLinksByFile[filename] = [mdxPath.originalPath];
              }
            });
            clearLogs();
            addLog(<BrokenLinksLog brokenLinksByFile={brokenLinksByFile} />);
          } catch (err) {
            addLog(<ErrorLog message={err instanceof Error ? err.message : 'unknown error'} />);
            await terminate(1);
          }

          await terminate(1);
        }
      )
      .command(
        'rename <from> <to>',
        'rename a file and update all internal link references',
        (yargs) =>
          yargs
            .positional('from', {
              describe: 'the file to rename',
              type: 'string',
            })
            .positional('to', {
              describe: 'the new name for the file',
              type: 'string',
            })
            .demandOption(['from', 'to'])
            .option('force', {
              type: 'boolean',
              default: false,
              description: 'rename files and skip errors',
            })
            .epilog('example: `mintlify rename introduction.mdx overview.mdx`'),
        async ({ from, to, force }) => {
          const hasMintJson = await checkForMintJson();
          if (!hasMintJson) {
            await checkForDocsJson();
          }
          await renameFilesAndUpdateLinksInContent(from, to, force);
          await terminate(0);
        }
      )
      .command(
        'update',
        'update the CLI to the latest version',
        () => undefined,
        async () => {
          await update({ packageName });
          await terminate(0);
        }
      )
      .command(
        'upgrade',
        'upgrade mint.json file to docs.json (current format)',
        () => undefined,
        async () => {
          const hasMintJson = await checkForMintJson();
          if (!hasMintJson) {
            await checkForDocsJson();
          }
          await upgradeConfig();
        }
      )
      .command(
        'migrate-mdx',
        'migrate MDX OpenAPI endpoint pages to x-mint extensions and docs.json',
        () => undefined,
        async () => {
          await migrateMdx();
          await terminate(0);
        }
      )
      .command(
        ['a11y', 'accessibility-check', 'a11y-check', 'accessibility'],
        'check for accessibility issues in documentation',
        (yargs) =>
          yargs
            .option('skip-contrast', {
              type: 'boolean',
              default: false,
              description: 'Skip color contrast checks',
            })
            .option('skip-alt-text', {
              type: 'boolean',
              default: false,
              description: 'Skip alt text checks on images and videos',
            })
            .check((argv) => {
              if (argv.skipContrast && argv.skipAltText) {
                throw new Error('Cannot skip both contrast and alt-text checks');
              }
              return true;
            })
            .example('mint a11y', 'Run all accessibility checks')
            .example('mint a11y --skip-contrast', 'Only check for missing alt text')
            .example('mint a11y --skip-alt-text', 'Only check color contrast'),
        async (argv) => {
          let accessibilityCheckTerminateCode = 0;
          let mdxLinterTerminateCode = 0;

          if (!argv.skipContrast) {
            accessibilityCheckTerminateCode = await accessibilityCheck();
          }

          if (!argv.skipAltText) {
            mdxLinterTerminateCode = await mdxLinter();
          }

          await terminate(accessibilityCheckTerminateCode || mdxLinterTerminateCode);
        }
      )
      .command(
        ['version', 'v'],
        'display the current version of the CLI and client',
        () => undefined,
        async () => {
          const { cli, client } = getVersions();
          addLog(
            <Text>
              <Text bold color="green">
                cli version
              </Text>{' '}
              {cli}
            </Text>
          );
          addLog(
            <Text>
              <Text bold color="green">
                client version
              </Text>{' '}
              {client}
            </Text>
          );
        }
      )
      .command(
        'new [directory]',
        'Create a new Mintlify documentation site',
        (yargs) =>
          yargs
            .positional('directory', {
              describe: 'The directory to initialize your documentation',
              type: 'string',
              default: '.',
            })
            .option('theme', {
              type: 'string',
              description: 'Theme for the documentation site',
            })
            .option('name', {
              type: 'string',
              description: 'Name of the documentation project',
            })
            .option('force', {
              type: 'boolean',
              default: false,
              description: 'Create the documentation in a subdirectory',
            }),
        async ({ directory, theme, name, force }) => {
          try {
            await init(directory, force, theme, name);
            await terminate(0);
          } catch (error) {
            addLog(
              <ErrorLog message={error instanceof Error ? error.message : 'error occurred'} />
            );
            await terminate(1);
          }
        }
      )
      // Print the help menu when the user enters an invalid command.
      .strictCommands()
      .demandCommand(1, 'unknown command. see above for the list of supported commands.')

      // Alias option flags --help = -h, default --version = -v
      .alias('h', 'help')
      .alias('v', 'version')

      .parse()
  );
};
