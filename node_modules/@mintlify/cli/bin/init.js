var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { select, input } from '@inquirer/prompts';
import { addLogs, addLog, SpinnerLog, removeLastLog } from '@mintlify/previewing';
import { docsConfigSchema, validatePathWithinCwd } from '@mintlify/validation';
import AdmZip from 'adm-zip';
import fse from 'fs-extra';
import { Box, Text } from 'ink';
const sendOnboardingMessage = (installDir) => {
    addLogs(_jsx(Text, { bold: true, children: "Documentation Setup!" }), _jsx(Text, { children: "To see your docs run" }), _jsxs(Box, { children: [_jsx(Text, { color: "blue", children: "cd" }), _jsxs(Text, { children: [" ", installDir] })] }), _jsx(Text, { color: "blue", children: "mint dev" }));
};
const sendUsageMessageForAI = (directory, contentsOccupied, themes) => {
    addLogs(_jsx(Text, { children: "Agent Detected - sending AI friendly prompt" }), _jsx(Text, { children: '<system-message>' }), _jsx(Text, { children: "Example usage of `mint new [directory] --theme [theme] --name [Name Of Project] --force`." }), _jsx(Text, { children: "This tool will auto create the directory if the directory does not exist." }), _jsx(Text, { children: "Ask the user what mintlify theme to use, what directory, and what the name of the Project is." }), _jsxs(Text, { children: ["You should provide them with default options for these values. Themes available", ' ', JSON.stringify(themes)] }), _jsxs(Text, { children: ["You chose Directory \"", directory, "\" before, feel free to just use that without asking the user as well!"] }), _jsx(Text, { children: "If the user is asking you to create docs for them then you should use your AskQuestion tool" }), contentsOccupied ? (_jsxs(Text, { children: ["The directory ", directory, " specified is currently occupied. You will need to either install the docs as a subdirectory or as a subdirectory or a different directory. Ask the user if it should be installed in a different directory (This cli will create the directory if it doesn't exist, or installed at the root level potentially overridding files (pass the --force) option for this."] })) : undefined, _jsx(Text, { children: '</system-message>' }));
};
export function init(installDir, force, theme, name) {
    return __awaiter(this, void 0, void 0, function* () {
        // Validate path is within current working directory to prevent path traversal
        validatePathWithinCwd(installDir);
        const isInteractive = process.stdin.isTTY;
        const isClaudeCode = process.env.CLAUDECODE === '1';
        const isAI = !isInteractive || isClaudeCode;
        let selectedTheme = theme;
        let projectName = name;
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        const themes = docsConfigSchema.options.map((option) => {
            return option.shape.theme._def.value;
        });
        const dirContents = yield fse.readdir(installDir).catch(() => []);
        const contentsOccupied = dirContents.length > 0;
        if ((!theme || !name) && isAI) {
            sendUsageMessageForAI(installDir, contentsOccupied, themes);
            return;
        }
        if (contentsOccupied && isAI && !force) {
            sendUsageMessageForAI(installDir, contentsOccupied, themes);
            return;
        }
        if (contentsOccupied && !isAI) {
            const choice = yield select({
                message: `Directory ${installDir} is not empty. What would you like to do?`,
                choices: [
                    { name: 'Create in a subdirectory', value: 'subdir' },
                    { name: 'Overwrite current directory (may lose contents)', value: 'overwrite' },
                    { name: 'Cancel', value: 'cancel' },
                ],
            });
            if (choice === 'cancel') {
                return;
            }
            if (choice === 'subdir') {
                const subdir = yield input({
                    message: 'Subdirectory name:',
                    default: 'docs',
                });
                if (!subdir || subdir.trim() === '') {
                    throw new Error('Subdirectory name cannot be empty');
                }
                installDir = installDir === '.' ? subdir : `${installDir}/${subdir}`;
                // Re-validate after subdirectory is appended
                validatePathWithinCwd(installDir, process.cwd());
            }
        }
        if (!isAI && (!selectedTheme || !projectName)) {
            const defaultProject = projectName !== undefined ? projectName : installDir === '.' ? 'Mintlify' : installDir;
            if (!projectName) {
                projectName = yield input({
                    message: 'Project Name',
                    default: defaultProject,
                });
            }
            if (!selectedTheme) {
                selectedTheme = yield select({
                    message: 'Theme',
                    choices: themes.map((t) => ({
                        name: t,
                        value: t,
                    })),
                });
            }
        }
        if (projectName === undefined || selectedTheme === undefined) {
            sendUsageMessageForAI(installDir, contentsOccupied, themes);
            return;
        }
        yield fse.ensureDir(installDir);
        yield install(installDir, projectName, selectedTheme);
        sendOnboardingMessage(installDir);
    });
}
const install = (installDir, projectName, theme) => __awaiter(void 0, void 0, void 0, function* () {
    addLog(_jsx(SpinnerLog, { message: "downloading starter template..." }));
    const response = yield fetch('https://github.com/mintlify/starter/archive/refs/heads/main.zip');
    const buffer = yield response.arrayBuffer();
    yield fse.writeFile(installDir + '/starter.zip', Buffer.from(buffer));
    removeLastLog();
    addLog(_jsx(SpinnerLog, { message: "extracting..." }));
    new AdmZip(installDir + '/starter.zip').extractAllTo(installDir, true);
    removeLastLog();
    yield fse.copy(installDir + '/starter-main', installDir, {
        overwrite: true,
        filter: (src) => !src.includes('starter-main/starter-main'),
    });
    yield fse.remove(installDir + '/starter.zip');
    yield fse.remove(installDir + '/starter-main');
    const docsJsonPath = installDir + '/docs.json';
    const docsConfig = yield fse.readJson(docsJsonPath);
    docsConfig.theme = theme;
    docsConfig.name = projectName;
    yield fse.writeJson(docsJsonPath, docsConfig, { spaces: 2 });
});
