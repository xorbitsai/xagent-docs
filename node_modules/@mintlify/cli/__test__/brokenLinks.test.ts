import { getBrokenInternalLinks } from '@mintlify/link-rot';
import { MdxPath } from '@mintlify/link-rot/dist/graph.js';
import * as previewing from '@mintlify/previewing';
import { mockProcessExit } from 'vitest-mock-process';

import { checkForMintJson } from '../src/helpers.js';
import { runCommand } from './utils.js';

vi.mock('../src/helpers.js', async () => {
  const actual = await import('../src/helpers.js');
  return {
    ...actual,
    checkForMintJson: vi.fn(),
  };
});

vi.mock('@mintlify/link-rot', async () => {
  const actual = await import('@mintlify/link-rot');
  return {
    ...actual,
    getBrokenInternalLinks: vi.fn(),
  };
});

const addLogSpy = vi.spyOn(previewing, 'addLog');
const clearLogsSpy = vi.spyOn(previewing, 'clearLogs');
const processExitMock = mockProcessExit();

describe('brokenLinks', () => {
  beforeEach(() => {
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.clearAllMocks();
  });

  it('success with no broken links', async () => {
    vi.mocked(checkForMintJson).mockResolvedValueOnce(true);
    vi.mocked(getBrokenInternalLinks).mockResolvedValueOnce([]);

    await runCommand('broken-links');

    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: { message: 'checking for broken links...' },
      })
    );
    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: { message: 'no broken links found' },
      })
    );
    expect(processExitMock).toHaveBeenCalledWith(0);
  });

  it('fails with broken links', async () => {
    vi.mocked(checkForMintJson).mockResolvedValueOnce(true);
    vi.mocked(getBrokenInternalLinks).mockResolvedValueOnce([
      {
        relativeDir: '.',
        filename: 'introduction.mdx',
        originalPath: '/api/invalid-path',
        pathType: 'internal',
      } as MdxPath,
    ]);

    await runCommand('broken-links');

    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: { message: 'checking for broken links...' },
      })
    );
    expect(clearLogsSpy).toHaveBeenCalled();
    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: {
          brokenLinksByFile: {
            'introduction.mdx': ['/api/invalid-path'],
          },
        },
      })
    );
    expect(processExitMock).toHaveBeenCalledWith(1);
  });

  it('fails when checking throws error', async () => {
    vi.mocked(checkForMintJson).mockResolvedValueOnce(true);
    vi.mocked(getBrokenInternalLinks).mockRejectedValueOnce(new Error('some error'));

    await runCommand('broken-links');

    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: { message: 'checking for broken links...' },
      })
    );
    expect(addLogSpy).toHaveBeenCalledWith(
      expect.objectContaining({
        props: { message: 'some error' },
      })
    );
    expect(processExitMock).toHaveBeenCalledWith(1);
  });
});
