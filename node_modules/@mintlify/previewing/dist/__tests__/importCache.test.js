import fse from 'fs-extra';
import { initializeImportCache, updateImportCacheForFile, removeFromImportCache, getImportedFilesFromCache, } from '../local-preview/listener/importCache.js';
vi.mock('fs-extra', () => ({
    default: { readFile: vi.fn() },
}));
vi.mock('@mintlify/prebuild', async () => {
    const actual = await vi.importActual('@mintlify/prebuild');
    return {
        ...actual,
        getFileListSync: vi.fn().mockReturnValue([]),
    };
});
const mockReadFile = vi.mocked(fse.readFile);
describe('importCache', () => {
    beforeEach(async () => {
        vi.clearAllMocks();
        await initializeImportCache('/base');
    });
    it('starts with empty cache', () => {
        expect(getImportedFilesFromCache()).toEqual(new Set());
    });
    it('tracks imports when file is updated', async () => {
        mockReadFile.mockResolvedValue(Buffer.from(`import Foo from './foo.mdx';\n\n<Foo />`));
        await updateImportCacheForFile('/base', 'page.mdx');
        expect(getImportedFilesFromCache()).toEqual(new Set(['/foo.mdx']));
    });
    it('returns newlyImported when import is added', async () => {
        mockReadFile.mockResolvedValue(Buffer.from(`import Bar from '/bar.mdx';\n\n<Bar />`));
        const result = await updateImportCacheForFile('/base', 'page.mdx');
        expect(result.newlyImported).toEqual(['/bar.mdx']);
    });
    it('returns noLongerImported when file is removed', async () => {
        mockReadFile.mockResolvedValue(Buffer.from(`import X from './x.mdx';\n\n<X />`));
        await updateImportCacheForFile('/base', 'a.mdx');
        const result = removeFromImportCache('a.mdx');
        expect(result.noLongerImported).toEqual(['/x.mdx']);
    });
    it('ignores non-mdx files', async () => {
        const result = await updateImportCacheForFile('/base', 'file.js');
        expect(result).toEqual({ newlyImported: [], noLongerImported: [] });
    });
    it('keeps import in cache if still referenced by another file', async () => {
        mockReadFile.mockResolvedValue(Buffer.from(`import S from './shared.mdx';\n\n<S />`));
        await updateImportCacheForFile('/base', 'a.mdx');
        await updateImportCacheForFile('/base', 'b.mdx');
        const result = removeFromImportCache('a.mdx');
        expect(result.noLongerImported).toEqual([]);
        expect(getImportedFilesFromCache()).toEqual(new Set(['/shared.mdx']));
    });
    it('detects when imports change in a file', async () => {
        mockReadFile.mockResolvedValue(Buffer.from(`import Old from './old.mdx';\n\n<Old />`));
        await updateImportCacheForFile('/base', 'page.mdx');
        mockReadFile.mockResolvedValue(Buffer.from(`import New from './new.mdx';\n\n<New />`));
        const result = await updateImportCacheForFile('/base', 'page.mdx');
        expect(result.newlyImported).toEqual(['/new.mdx']);
        expect(result.noLongerImported).toEqual(['/old.mdx']);
    });
});
