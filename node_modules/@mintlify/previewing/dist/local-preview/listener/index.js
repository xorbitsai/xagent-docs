import { jsx as _jsx } from "react/jsx-runtime";
import { findAndRemoveImports, hasImports, getFileCategory, validate, stringifyTree, isMintIgnored, } from '@mintlify/common';
import { createPage, MintConfigUpdater, DocsConfigUpdater, preparseMdxTree, prebuild, } from '@mintlify/prebuild';
import Chalk from 'chalk';
import chokidar from 'chokidar';
import { promises as _promises } from 'fs';
import fse from 'fs-extra';
import fs from 'fs/promises';
import yaml from 'js-yaml';
import pathUtil from 'path';
import { CMD_EXEC_PATH, NEXT_PROPS_PATH, NEXT_PUBLIC_PATH, CLIENT_PATH } from '../../constants.js';
import { addChangeLog, addErrorLog, clearErrorLogs, getCurrentErrorLogs, } from '../../logging-state.js';
import { AddedLog, DeletedLog, EditedLog, WarningLog, InfoLog, ErrorLog } from '../../logs.js';
import { generateDependentSnippets } from './generateDependentSnippets.js';
import { generatePagesWithImports } from './generatePagesWithImports.js';
import { getDocsState } from './getDocsState.js';
import { initializeImportCache, updateImportCacheForFile, removeFromImportCache, getImportedFilesFromCache, syncImportedFileLocations, } from './importCache.js';
import { resolveAllImports } from './resolveAllImports.js';
import { updateCustomLanguages, updateGeneratedNav, updateOpenApiFiles, upsertOpenApiFile, } from './update.js';
import { getMintIgnoreGlobs, handleParseError, isFileSizeValid, isJsonValid, shouldRegenerateNavForPage, suppressParseError, } from './utils.js';
const { readFile } = _promises;
const frontmatterHashes = new Map();
const listener = (callback, options = {}) => {
    const mintIgnoreGlobs = getMintIgnoreGlobs();
    chokidar
        .watch(CMD_EXEC_PATH, {
        ignoreInitial: true,
        ignored: (filePath) => {
            const relativePath = pathUtil.isAbsolute(filePath)
                ? pathUtil.relative(CMD_EXEC_PATH, filePath)
                : filePath;
            if (!relativePath) {
                return false;
            }
            return isMintIgnored(relativePath, mintIgnoreGlobs);
        },
        cwd: CMD_EXEC_PATH,
    })
        .on('add', (filename) => onAddEvent(filename, callback, options))
        .on('change', (filename) => onChangeEvent(filename, callback, options))
        .on('unlink', (filename) => onUnlinkEvent(filename, options));
};
const onAddEvent = async (filename, callback, options) => {
    if (isMintIgnored(filename, getMintIgnoreGlobs())) {
        return;
    }
    try {
        const category = await onUpdateEvent(filename, callback, options);
        if (category) {
            addChangeLog(_jsx(AddedLog, { filename: filename }));
        }
    }
    catch (error) {
        console.error(error.message);
    }
};
const onChangeEvent = async (filename, callback, options) => {
    if (isMintIgnored(filename, getMintIgnoreGlobs())) {
        return;
    }
    try {
        const category = await onUpdateEvent(filename, callback, options);
        if (category) {
            addChangeLog(_jsx(EditedLog, { filename: filename }));
        }
    }
    catch (error) {
        console.error(error.message);
    }
};
const onUnlinkEvent = async (filename, options) => {
    if (isMintIgnored(filename, getMintIgnoreGlobs())) {
        return;
    }
    try {
        const importedFiles = getImportedFilesFromCache();
        const potentialCategory = getFileCategory(filename, { importedFiles });
        if (potentialCategory == null) {
            const importChanges = removeFromImportCache(filename);
            await syncImportedFileLocations(importChanges);
            return;
        }
        const targetPath = getTargetPath(potentialCategory, filename);
        if (potentialCategory === 'page' ||
            potentialCategory === 'snippet' ||
            potentialCategory === 'mintConfig' ||
            potentialCategory === 'docsConfig' ||
            potentialCategory === 'staticFile' ||
            potentialCategory === 'snippet-v2' ||
            potentialCategory === 'css' ||
            potentialCategory === 'js' ||
            potentialCategory === 'generatedStaticFile') {
            await fse.remove(targetPath);
        }
        switch (potentialCategory) {
            case 'mintConfig':
                console.error('mint.json has been deleted.');
                await validateConfigFiles();
                break;
            case 'docsConfig':
                console.error('docs.json has been deleted.');
                await validateConfigFiles();
                break;
            case 'mintIgnore':
                addChangeLog(_jsx(WarningLog, { message: ".mintignore has been deleted. Rebuilding..." }));
                try {
                    await fse.emptyDir(NEXT_PUBLIC_PATH);
                    await fse.emptyDir(NEXT_PROPS_PATH);
                    const prebuildResult = await prebuild(CMD_EXEC_PATH, options);
                    await initializeImportCache(CMD_EXEC_PATH, prebuildResult?.fileImportsMap);
                }
                catch (err) {
                    console.error('Error rebuilding after .mintignore deletion:', err);
                }
                break;
        }
        const importChanges = removeFromImportCache(filename);
        await syncImportedFileLocations(importChanges);
        addChangeLog(_jsx(DeletedLog, { filename: filename }));
    }
    catch (error) {
        console.error(error.message);
    }
};
const getTargetPath = (potentialCategory, filePath) => {
    switch (potentialCategory) {
        case 'page':
            return pathUtil.join(NEXT_PROPS_PATH, filePath);
        case 'mintConfig':
            return pathUtil.join(NEXT_PROPS_PATH, 'mint.json');
        case 'docsConfig':
            return pathUtil.join(NEXT_PROPS_PATH, 'docs.json');
        case 'potentialYamlOpenApiSpec':
        case 'potentialJsonOpenApiSpec':
            return pathUtil.join(NEXT_PROPS_PATH, 'openApiFiles.json');
        case 'generatedStaticFile':
            return pathUtil.join(NEXT_PUBLIC_PATH, filePath);
        case 'mintIgnore':
            return pathUtil.join(NEXT_PROPS_PATH, 'mint-ignore.json');
        case 'snippet':
        case 'staticFile':
        case 'snippet-v2':
        case 'css':
        case 'js':
            return pathUtil.join(NEXT_PUBLIC_PATH, filePath);
        default:
            throw new Error('Invalid category');
    }
};
const validateConfigFiles = async () => {
    try {
        const mintConfigPath = pathUtil.join(CMD_EXEC_PATH, 'mint.json');
        const docsConfigPath = pathUtil.join(CMD_EXEC_PATH, 'docs.json');
        const mintConfigExists = await fse.pathExists(mintConfigPath);
        const docsConfigExists = await fse.pathExists(docsConfigPath);
        if (!mintConfigExists && !docsConfigExists) {
            console.error('âš ï¸ Error: Neither mint.json nor docs.json found in the directory');
            process.exit(1);
        }
    }
    catch (error) {
        console.error('âš ï¸ Error validating configuration files:', error);
    }
};
/**
 * This function is called when a file is added or changed
 * @param filename
 * @returns FileCategory
 */
const onUpdateEvent = async (filename, callback, options = {}) => {
    clearErrorLogs();
    const filePath = pathUtil.join(CMD_EXEC_PATH, filename);
    const importChanges = await updateImportCacheForFile(CMD_EXEC_PATH, filename);
    await syncImportedFileLocations(importChanges);
    const importedFiles = getImportedFilesFromCache();
    const potentialCategory = getFileCategory(filename, { importedFiles });
    if (potentialCategory == null) {
        callback();
        return null;
    }
    let regenerateNav = false;
    let category = potentialCategory === 'potentialYamlOpenApiSpec' ||
        potentialCategory === 'potentialJsonOpenApiSpec'
        ? 'staticFile'
        : potentialCategory;
    const targetPath = getTargetPath(potentialCategory, filename);
    switch (potentialCategory) {
        case 'page': {
            let contentStr = (await readFile(filePath)).toString();
            regenerateNav = await shouldRegenerateNavForPage(filename, contentStr, frontmatterHashes, handleParseError);
            const tree = await preparseMdxTree(contentStr, CMD_EXEC_PATH, filePath, suppressParseError);
            const importsResponse = await findAndRemoveImports(tree);
            if (hasImports(importsResponse)) {
                contentStr = stringifyTree(await resolveAllImports({ ...importsResponse, filename }));
            }
            const { pageContent } = await createPage(filename, contentStr, CMD_EXEC_PATH, [], [], handleParseError);
            await fse.outputFile(targetPath, pageContent, {
                flag: 'w',
            });
            break;
        }
        case 'snippet': {
            await fse.copy(filePath, targetPath);
            break;
        }
        case 'snippet-v2': {
            let contentStr = (await readFile(filePath)).toString();
            const tree = await preparseMdxTree(contentStr, CMD_EXEC_PATH, filePath, handleParseError);
            const importsResponse = await findAndRemoveImports(tree);
            if (hasImports(importsResponse)) {
                contentStr = stringifyTree(await resolveAllImports({ ...importsResponse, filename }));
            }
            await fse.outputFile(targetPath, contentStr, {
                flag: 'w',
            });
            const updatedSnippets = await generateDependentSnippets(filename, importsResponse);
            await generatePagesWithImports(new Set(updatedSnippets));
            break;
        }
        case 'mintConfig':
        case 'docsConfig': {
            const { valid, error } = isJsonValid(filePath);
            if (!valid) {
                addErrorLog(_jsx(ErrorLog, { message: `Syntax error in ${filename}: ${error}` }));
                return null;
            }
            regenerateNav = true;
            try {
                const { mintConfig, openApiFiles, docsConfig } = await getDocsState(handleParseError);
                if (mintConfig) {
                    await MintConfigUpdater.writeConfigFile(mintConfig, CLIENT_PATH);
                }
                await DocsConfigUpdater.writeConfigFile(docsConfig, CLIENT_PATH);
                await updateOpenApiFiles(openApiFiles, suppressParseError);
                await updateCustomLanguages(docsConfig, suppressParseError);
            }
            catch (err) {
                if (getCurrentErrorLogs().length > 0) {
                    // no-op to suppress duplicate error logging
                    return null;
                }
                else {
                    console.error(err);
                }
            }
            break;
        }
        case 'mintIgnore': {
            try {
                addChangeLog(_jsx(InfoLog, { message: ".mintignore has been updated. Rebuilding..." }));
                await fse.emptyDir(NEXT_PUBLIC_PATH);
                await fse.emptyDir(NEXT_PROPS_PATH);
                const prebuildResult = await prebuild(CMD_EXEC_PATH, options);
                await initializeImportCache(CMD_EXEC_PATH, prebuildResult?.fileImportsMap);
            }
            catch (err) {
                console.error(err.message);
            }
            break;
        }
        case 'potentialYamlOpenApiSpec':
        case 'potentialJsonOpenApiSpec': {
            let doc;
            try {
                const file = await fs.readFile(filePath, 'utf-8');
                const { schema } = await validate(yaml.load(file));
                doc = schema;
            }
            catch {
                doc = undefined;
            }
            if (doc) {
                await upsertOpenApiFile({
                    filename: pathUtil.parse(filename).name,
                    originalFileLocation: '/' + filename,
                    spec: doc,
                });
                await updateOpenApiFiles();
                regenerateNav = true;
                category = 'openApi';
            }
            else {
                const customLanguages = JSON.parse(await fs.readFile(pathUtil.join(NEXT_PROPS_PATH, 'customLanguages.json'), 'utf-8'));
                let updated = false;
                for (const [index, customLanguage] of customLanguages.entries()) {
                    if (filePath.endsWith(customLanguage.filePath)) {
                        updated = true;
                        const file = await fs.readFile(filePath, 'utf-8');
                        customLanguages[index] = { content: file, filePath: customLanguage.filePath };
                        break;
                    }
                }
                if (updated) {
                    await fs.writeFile(pathUtil.join(NEXT_PROPS_PATH, 'customLanguages.json'), JSON.stringify(customLanguages, null, 2));
                }
            }
            break;
        }
        case 'css':
        case 'js':
        case 'generatedStaticFile':
        case 'staticFile': {
            if (await isFileSizeValid(filePath, 20)) {
                await fse.copy(filePath, targetPath);
            }
            else {
                console.error(Chalk.red(`ðŸš¨ The file at ${filename} is too big. The maximum file size is 20 mb.`));
            }
            break;
        }
    }
    if (regenerateNav) {
        // TODO: Instead of re-generating the entire nav, optimize by just updating the specific page that changed.
        await updateGeneratedNav(suppressParseError);
    }
    callback();
    return category;
};
export { initializeImportCache };
export default listener;
