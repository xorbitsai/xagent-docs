import { parseFrontmatter, processMintIgnoreString, optionallyAddLeadingSlash, } from '@mintlify/common';
import crypto from 'crypto';
import { promises as _promises, readFileSync, existsSync } from 'fs';
import fse from 'fs-extra';
import pathUtil from 'path';
import { CMD_EXEC_PATH } from '../../constants.js';
import { addRawErrorLog } from '../../logging-state.js';
const { stat } = _promises;
export const getFileExtension = (filename) => {
    return filename.substring(filename.lastIndexOf('.') + 1, filename.length) || filename;
};
export const isFileSizeValid = async (path, maxFileSizeInMb) => {
    const maxFileSizeBytes = maxFileSizeInMb * 1000000;
    const stats = await stat(path);
    return stats.size <= maxFileSizeBytes;
};
export function isError(obj) {
    return Object.prototype.toString.call(obj) === '[object Error]';
}
export const readJsonFile = async (path) => {
    const file = await fse.readFile(path, 'utf-8');
    return JSON.parse(file);
};
export const getMintIgnoreGlobs = () => {
    const mintIgnorePath = pathUtil.join(CMD_EXEC_PATH, '.mintignore');
    if (existsSync(mintIgnorePath)) {
        const content = readFileSync(mintIgnorePath, 'utf8');
        return processMintIgnoreString(content);
    }
    return [];
};
export const isJsonValid = (filePath) => {
    try {
        const content = readFileSync(filePath, 'utf-8');
        if (!content.trim()) {
            return { valid: false, error: 'File is empty' };
        }
        JSON.parse(content);
        return { valid: true };
    }
    catch (error) {
        return { valid: false, error: error.message };
    }
};
export const shouldRegenerateNavForPage = async (filename, contentStr, frontmatterHashes, onError) => {
    try {
        const { attributes: currentFrontmatter } = parseFrontmatter(contentStr);
        const prevFrontmatterHash = frontmatterHashes.get(filename);
        const currentFrontmatterHash = crypto
            .createHash('md5')
            .update(JSON.stringify(currentFrontmatter))
            .digest('hex');
        if (!prevFrontmatterHash) {
            frontmatterHashes.set(filename, currentFrontmatterHash);
            return true;
        }
        if (currentFrontmatterHash !== prevFrontmatterHash) {
            frontmatterHashes.set(filename, currentFrontmatterHash);
            return true;
        }
        frontmatterHashes.set(filename, currentFrontmatterHash);
        return false;
    }
    catch (error) {
        const message = `Error parsing frontmatter for ${filename}, regenerating nav: ${error instanceof Error ? error.message : String(error)}`;
        if (onError) {
            onError(message);
        }
        else {
            console.warn(message);
        }
        return true;
    }
};
export function normalizePathForComparison(filePath) {
    return optionallyAddLeadingSlash(filePath).toLowerCase();
}
export const handleParseError = (message) => {
    const trimmed = message.trim();
    if (trimmed) {
        addRawErrorLog(trimmed);
    }
};
export const suppressParseError = () => {
    // no-op to suppress duplicate error logging
};
