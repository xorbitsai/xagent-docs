import { optionallyAddLeadingSlash, optionallyRemoveLeadingSlash, isSnippetExtension, extractImportSources, resolveImportPath, findAndRemoveImports, hasImports, stringifyTree, getFileCategory, } from '@mintlify/common';
import { getFileExtension } from '@mintlify/prebuild';
import { getFileListSync, createPage, preparseMdxTree } from '@mintlify/prebuild';
import fse from 'fs-extra';
import { join } from 'path';
import { CMD_EXEC_PATH, NEXT_PROPS_PATH, NEXT_PUBLIC_PATH } from '../../constants.js';
import { resolveAllImports } from './resolveAllImports.js';
import { handleParseError, normalizePathForComparison, suppressParseError } from './utils.js';
const fileImportsMap = new Map();
const importerCounts = new Map();
const addImporter = (path) => {
    const count = importerCounts.get(path) ?? 0;
    importerCounts.set(path, count + 1);
    return count === 0;
};
const removeImporter = (path) => {
    const count = importerCounts.get(path);
    if (count == null)
        return false;
    if (count <= 1) {
        importerCounts.delete(path);
        return true;
    }
    importerCounts.set(path, count - 1);
    return false;
};
const extractFileImports = async (baseDir, filename) => {
    const filePath = join(baseDir, filename);
    try {
        const content = (await fse.readFile(filePath)).toString();
        const tree = await preparseMdxTree(content, baseDir, filePath, suppressParseError);
        const importSources = extractImportSources(tree);
        const imports = new Set();
        for (const source of importSources) {
            const resolvedPath = resolveImportPath(source, optionallyAddLeadingSlash(filename));
            if (resolvedPath != null) {
                imports.add(normalizePathForComparison(resolvedPath));
            }
        }
        return imports;
    }
    catch (err) {
        console.log('Error extracting imports from file');
        console.log(filename);
        console.log(err);
        return new Set();
    }
};
export const initializeImportCache = async (baseDir, prebuildImportMap) => {
    fileImportsMap.clear();
    importerCounts.clear();
    if (prebuildImportMap) {
        for (const [filePath, imports] of prebuildImportMap) {
            const normalizedPath = normalizePathForComparison(filePath);
            fileImportsMap.set(normalizedPath, imports);
            for (const imp of imports) {
                addImporter(imp);
            }
        }
        return;
    }
    const allFiles = getFileListSync(baseDir).filter((file) => isSnippetExtension(getFileExtension(file)));
    await Promise.all(allFiles.map(async (filename) => {
        const normalizedPath = normalizePathForComparison(filename);
        const imports = await extractFileImports(baseDir, filename);
        fileImportsMap.set(normalizedPath, imports);
        for (const imp of imports) {
            addImporter(imp);
        }
    }));
};
export const updateImportCacheForFile = async (baseDir, filename) => {
    if (!isSnippetExtension(getFileExtension(filename))) {
        return { newlyImported: [], noLongerImported: [] };
    }
    const normalizedPath = normalizePathForComparison(filename);
    const newImports = await extractFileImports(baseDir, filename);
    const oldImports = fileImportsMap.get(normalizedPath) ?? new Set();
    const newlyImported = [];
    const noLongerImported = [];
    for (const imp of newImports) {
        if (!oldImports.has(imp) && addImporter(imp)) {
            newlyImported.push(imp);
        }
    }
    for (const imp of oldImports) {
        if (!newImports.has(imp) && removeImporter(imp)) {
            noLongerImported.push(imp);
        }
    }
    fileImportsMap.set(normalizedPath, newImports);
    return { newlyImported, noLongerImported };
};
export const removeFromImportCache = (filename) => {
    const normalizedPath = normalizePathForComparison(filename);
    const oldImports = fileImportsMap.get(normalizedPath);
    if (oldImports == null) {
        return { newlyImported: [], noLongerImported: [] };
    }
    const noLongerImported = [];
    for (const imp of oldImports) {
        if (removeImporter(imp)) {
            noLongerImported.push(imp);
        }
    }
    fileImportsMap.delete(normalizedPath);
    return { newlyImported: [], noLongerImported };
};
export const getImportedFilesFromCache = () => {
    return new Set(Array.from(importerCounts.keys(), (key) => key.toLowerCase()));
};
const isSnippetByFolder = (path) => {
    const normalized = normalizePathForComparison(path).toLowerCase();
    return normalized.startsWith('/snippets/') || normalized.startsWith('/_snippets/');
};
const resolveFileImports = async (sourcePath, relativePath) => {
    let contentStr = (await fse.readFile(sourcePath)).toString();
    const tree = await preparseMdxTree(contentStr, CMD_EXEC_PATH, sourcePath, handleParseError);
    const importsResponse = await findAndRemoveImports(tree);
    if (hasImports(importsResponse)) {
        contentStr = stringifyTree(await resolveAllImports({ ...importsResponse, filename: relativePath }));
    }
    return contentStr;
};
export const syncImportedFileLocations = async (changes) => {
    for (const importedPath of changes.newlyImported) {
        if (isSnippetByFolder(importedPath))
            continue;
        if (!isSnippetExtension(getFileExtension(importedPath)))
            continue;
        const relativePath = optionallyRemoveLeadingSlash(importedPath);
        const sourcePath = join(CMD_EXEC_PATH, relativePath);
        const targetPath = join(NEXT_PUBLIC_PATH, relativePath);
        try {
            const contentStr = await resolveFileImports(sourcePath, relativePath);
            await fse.outputFile(targetPath, contentStr, { flag: 'w' });
            await fse.remove(join(NEXT_PROPS_PATH, relativePath));
        }
        catch (err) {
            console.log('Error processing newly imported snippet');
            console.log(relativePath);
            console.log(err);
        }
    }
    for (const importedPath of changes.noLongerImported) {
        if (isSnippetByFolder(importedPath))
            continue;
        if (!isSnippetExtension(getFileExtension(importedPath)))
            continue;
        const relativePath = optionallyRemoveLeadingSlash(importedPath);
        const sourcePath = join(CMD_EXEC_PATH, relativePath);
        await fse.remove(join(NEXT_PUBLIC_PATH, relativePath));
        if (getFileCategory(relativePath) !== 'page')
            continue;
        if (await fse.pathExists(sourcePath)) {
            try {
                const contentStr = await resolveFileImports(sourcePath, relativePath);
                const { pageContent } = await createPage(relativePath, contentStr, CMD_EXEC_PATH, [], [], suppressParseError);
                await fse.outputFile(join(NEXT_PROPS_PATH, relativePath), pageContent, { flag: 'w' });
            }
            catch (err) {
                console.log('Error regenerating page after import status change');
                console.log(relativePath);
                console.log(err);
            }
        }
    }
};
