import { jsx as _jsx } from "react/jsx-runtime";
import open from 'better-opn';
import express from 'express';
import { createServer } from 'http';
import { Server as SocketServer } from 'socket.io';
import { CMD_EXEC_PATH, NEXT_PUBLIC_PATH } from '../constants.js';
import { addLog, removeLastLog } from '../logging-state.js';
import { LaunchLog, UpdateLog } from '../logs.js';
import { maybeFixMissingWindowsEnvVar } from '../util.js';
import listener, { initializeImportCache } from './listener/index.js';
import { getLocalNetworkIp } from './network.js';
import { setupNext } from './setupNext.js';
export const run = async (argv) => {
    const port = argv.port || '3000';
    const currentPort = parseInt(port, 10) || 3000;
    const app = express();
    const server = createServer(app);
    const io = new SocketServer(server);
    const requestHandler = await setupNext();
    const localIp = getLocalNetworkIp();
    // next-server is bugged, public files added after starting aren't served
    app.use('/', express.static(NEXT_PUBLIC_PATH));
    app.all('*', (req, res) => requestHandler(req, res));
    const onChange = () => {
        io.emit('reload');
    };
    server.listen(currentPort, () => {
        removeLastLog();
        if (argv.needsUpdate) {
            addLog(_jsx(UpdateLog, { updateCommand: `${argv.packageName} update` }));
        }
        addLog(_jsx(LaunchLog, { localUrl: `http://localhost:${port}`, networkUrl: localIp ? `http://${localIp}:${port}` : undefined }));
        /**
         * We're running into a known bug with the `open` package, where Windows machines error out because process.env.SYSTEMROOT is not set:
         * https://github.com/sindresorhus/open/issues/292
         *
         * Let's use the same workaround that this project did:
         * https://github.com/sanity-io/sanity/pull/4221/files#diff-aeb574e1becf61f21fdf87fbea709669c93d604d660dad4b0f9e24527a2fb54bR256-R262
         */
        maybeFixMissingWindowsEnvVar();
        if (argv.open) {
            void open(`http://localhost:${port}`);
        }
        // exit with successful status
        const onExit = () => {
            process.exit(0);
        };
        process.on('SIGINT', onExit);
        process.on('SIGTERM', onExit);
    });
    await initializeImportCache(CMD_EXEC_PATH, argv.fileImportsMap);
    listener(onChange);
};
