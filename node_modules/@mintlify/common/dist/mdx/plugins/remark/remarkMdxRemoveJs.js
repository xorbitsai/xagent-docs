import { walk } from 'estree-walker';
import { remove } from 'unist-util-remove';
import { CONTINUE, visit } from 'unist-util-visit';
import { isMdxJsEsm } from '../../utils.js';
const objectEstree = {
    type: 'Program',
    body: [
        {
            type: 'ExpressionStatement',
            expression: {
                type: 'ObjectExpression',
                properties: [],
            },
        },
    ],
    sourceType: 'module',
    comments: [],
};
const arrayEstree = {
    type: 'Program',
    body: [
        {
            type: 'ExpressionStatement',
            expression: {
                type: 'ArrayExpression',
                elements: [],
            },
        },
    ],
    sourceType: 'module',
    comments: [],
};
const falseEstree = {
    type: 'Program',
    body: [
        {
            type: 'ExpressionStatement',
            expression: {
                type: 'Literal',
                value: false,
                raw: 'false',
            },
        },
    ],
    sourceType: 'module',
    comments: [],
};
const trueEstree = {
    type: 'Program',
    body: [
        {
            type: 'ExpressionStatement',
            expression: {
                type: 'Literal',
                value: true,
                raw: 'true',
            },
        },
    ],
    sourceType: 'module',
    comments: [],
};
function createStringEstree(str) {
    return {
        type: 'Program',
        body: [
            {
                type: 'ExpressionStatement',
                expression: {
                    type: 'Literal',
                    value: str,
                    raw: `'${str}'`,
                },
            },
        ],
        sourceType: 'module',
        comments: [],
    };
}
const numberEstree = {
    type: 'Program',
    body: [
        {
            type: 'ExpressionStatement',
            expression: {
                type: 'Literal',
                value: 1,
                raw: '1',
            },
        },
    ],
    sourceType: 'module',
    comments: [],
};
const DEFAULT_PROP_EXPRESSIONS = {
    placement: { value: '"bottom"', estree: createStringEstree('bottom') },
    deflectionEmail: { value: '""', estree: createStringEstree('') },
    searchSites: { value: '[]', estree: arrayEstree },
    spendLimit: { value: '1', estree: numberEstree },
    sampleQuestions: { value: '[]', estree: arrayEstree },
    slack: { value: 'false', estree: falseEstree },
    subdomain: { value: '""', estree: createStringEstree('') },
    context: { value: '{}', estree: objectEstree },
    title: { value: '""', estree: createStringEstree('') },
    description: { value: '""', estree: createStringEstree('') },
    icon: { value: '""', estree: createStringEstree('') },
    href: { value: '""', estree: createStringEstree('') },
    iconType: { value: '"regular"', estree: createStringEstree('regular') },
    enabled: { value: '"false"', estree: createStringEstree('false') },
    name: { value: '""', estree: createStringEstree('') },
    mcp: { value: '{}', estree: objectEstree },
    openapi: { value: '""', estree: createStringEstree('') },
    servers: { value: '[]', estree: arrayEstree },
    securitySchemes: { value: '{}', estree: objectEstree },
    security: { value: '{}', estree: objectEstree },
    authMethod: { value: '"bearer"', estree: createStringEstree('bearer') },
    playground: {
        value: '"interactive"',
        estree: createStringEstree('interactive'),
    },
    server: { value: '""', estree: createStringEstree('') },
    metadata: { value: '{}', estree: objectEstree },
    content: { value: '""', estree: createStringEstree('') },
    codeSamples: { value: '[]', estree: arrayEstree },
    lang: { value: '""', estree: createStringEstree('') },
    label: { value: '""', estree: createStringEstree('') },
    source: { value: '""', estree: createStringEstree('') },
    examples: { value: '{}', estree: objectEstree },
    summary: { value: '""', estree: createStringEstree('') },
    value: { value: '{}', estree: objectEstree },
    contextual: { value: '{ "options": [] }', estree: falseEstree },
    api: { value: '{}', estree: objectEstree },
    navigation: { value: '{}', estree: objectEstree },
    asyncapi: { value: '""', estree: createStringEstree('') },
    directory: { value: '""', estree: createStringEstree('') },
    'x-hidden': { value: '"true"', estree: trueEstree },
    'x-excluded': { value: '"true"', estree: trueEstree },
};
const REACT_HOOKS = [
    'useState',
    'useEffect',
    'useRef',
    'useCallback',
    'useMemo',
    'useReducer',
    'useContext',
    'useLayoutEffect',
    'useImperativeHandle',
    'useDebugValue',
    'useDeferredValue',
    'useTransition',
    'useId',
    'useSyncExternalStore',
    'useInsertionEffect',
    'useOptimistic',
    'useActionState',
];
export function isStringSafe(value) {
    switch (true) {
        case value === 'true':
        case value === 'false':
        // purely alphanumeric string
        case /^[_a-zA-Z0-9]+$/.test(value):
        // string literal with quotes
        case /^'[_a-zA-Z0-9\s`".\-\\{}\?\(\)&*^%#@!~=+\[\]|:;,\/]+'$/.test(value):
        case /^"[_a-zA-Z0-9\s`'.\-\\{}\?\(\)&*^%#@!~=+\[\]|:;,\/]+"$/.test(value):
        case /^`[_a-zA-Z0-9\s'".\-\\{}\?\(\)&*^%#@!~=+\[\]|:;,\/]+`$/.test(value):
        // purely alphanumeric string prefixed with `!!`
        case /^!![_a-zA-Z0-9]+$/.test(value):
        // purely alphanumeric string wrapped in parens
        case /^\([_a-zA-Z0-9]+\)$/.test(value):
        // purely alphanumeric string prefixed with `!!` wrapped in parens
        case /^\(!![_a-zA-Z0-9]+\)$/.test(value):
            return true;
        // could contain arbitrary javascript
        default:
            return false;
    }
}
function isStylePropertyValueSafe(property) {
    if (property.computed)
        return false;
    const value = property.value;
    if (value.type === 'Literal')
        return true;
    if (value.type === 'UnaryExpression' &&
        value.operator === '-' &&
        value.argument.type === 'Literal' &&
        typeof value.argument.value === 'number') {
        return true;
    }
    return false;
}
export function filterStyleProperties(estree) {
    if (!estree.body.length)
        return null;
    const stmt = estree.body[0];
    if ((stmt === null || stmt === void 0 ? void 0 : stmt.type) !== 'ExpressionStatement')
        return null;
    const expr = stmt.expression;
    if (expr.type !== 'ObjectExpression')
        return null;
    const safeProperties = expr.properties.filter((prop) => prop.type === 'Property' && isStylePropertyValueSafe(prop));
    if (safeProperties.length === 0)
        return null;
    const newExpr = Object.assign(Object.assign({}, expr), { properties: safeProperties });
    return Object.assign(Object.assign({}, estree), { body: [
            Object.assign(Object.assign({}, stmt), { expression: newExpr }),
        ] });
}
export function rebuildStyleValue(properties) {
    const parts = properties.map((prop) => {
        const key = prop.key.type === 'Identifier'
            ? prop.key.name
            : prop.key.type === 'Literal'
                ? `'${String(prop.key.value).replace(/'/g, "\\'")}'`
                : '';
        let val = '';
        if (prop.value.type === 'Literal') {
            val =
                typeof prop.value.value === 'string'
                    ? `'${String(prop.value.value).replace(/'/g, "\\'")}'`
                    : String(prop.value.value);
        }
        else if (prop.value.type === 'UnaryExpression' &&
            prop.value.operator === '-' &&
            prop.value.argument.type === 'Literal') {
            val = `-${prop.value.argument.value}`;
        }
        return `${key}: ${val}`;
    });
    return `{ ${parts.join(', ')} }`;
}
function isFunction(estree) {
    if (!estree.body.length)
        return false;
    let hasFunctionDeclaration = false;
    walk(estree, {
        enter(node) {
            if (node.type === 'FunctionDeclaration' ||
                node.type === 'ArrowFunctionExpression' ||
                node.type === 'FunctionExpression') {
                hasFunctionDeclaration = true;
                return this.skip();
            }
            if (node.type === 'ExportDefaultDeclaration' &&
                (node.declaration.type === 'FunctionDeclaration' ||
                    node.declaration.type === 'FunctionExpression' ||
                    node.declaration.type === 'ArrowFunctionExpression')) {
                hasFunctionDeclaration = true;
                return this.skip();
            }
            if (node.type === 'VariableDeclaration' &&
                node.declarations.some((decl) => decl.init &&
                    (decl.init.type === 'ArrowFunctionExpression' ||
                        decl.init.type === 'FunctionExpression'))) {
                hasFunctionDeclaration = true;
                return this.skip();
            }
        },
    });
    return hasFunctionDeclaration;
}
function isArrayOfStringLiterals(estree) {
    const stmt = estree.body[0];
    if (estree.body.length !== 1 || (stmt === null || stmt === void 0 ? void 0 : stmt.type) !== 'ExpressionStatement')
        return false;
    if (stmt.expression.type !== 'ArrayExpression')
        return false;
    return stmt.expression.elements.every((el) => (el === null || el === void 0 ? void 0 : el.type) === 'Literal' && typeof el.value === 'string');
}
export function remarkMdxRemoveJs() {
    return (tree) => {
        remove(tree, ['mdxTextExpression', 'mdxFlowExpression']);
        remove(tree, (node) => {
            var _a;
            if (!isMdxJsEsm(node))
                return false;
            if (((_a = node.data) === null || _a === void 0 ? void 0 : _a.estree) && !isFunction(node.data.estree))
                return false;
            const value = node.value;
            const containsReact = REACT_HOOKS.some((hook) => value.includes(hook) || value.includes('React.' + hook.toLowerCase()));
            return containsReact;
        });
        visit(tree, (node) => {
            if (!('attributes' in node))
                return CONTINUE;
            const newAttributes = node.attributes.map((attr) => {
                var _a, _b, _c, _d, _e, _f;
                if (attr.type === 'mdxJsxAttribute' && !(attr.value instanceof Object))
                    return attr;
                if (typeof attr.value === 'string' && isStringSafe(attr.value))
                    return attr;
                if (attr.type === 'mdxJsxAttribute' && attr.value instanceof Object) {
                    if (isStringSafe(attr.value.value))
                        return attr;
                    if (((_a = attr.value.data) === null || _a === void 0 ? void 0 : _a.estree) && isArrayOfStringLiterals(attr.value.data.estree))
                        return attr;
                    if (attr.name === 'style' && ((_b = attr.value.data) === null || _b === void 0 ? void 0 : _b.estree)) {
                        const filteredEstree = filterStyleProperties(attr.value.data.estree);
                        if (filteredEstree) {
                            const stmt = filteredEstree.body[0];
                            if ((stmt === null || stmt === void 0 ? void 0 : stmt.type) === 'ExpressionStatement' &&
                                stmt.expression.type === 'ObjectExpression') {
                                attr.value.value = rebuildStyleValue(stmt.expression.properties);
                                attr.value.data.estree = filteredEstree;
                                return attr;
                            }
                        }
                        return undefined;
                    }
                    if (Object.keys(DEFAULT_PROP_EXPRESSIONS).includes(attr.name)) {
                        attr.value.value = (_d = (_c = DEFAULT_PROP_EXPRESSIONS[attr.name]) === null || _c === void 0 ? void 0 : _c.value) !== null && _d !== void 0 ? _d : '{}';
                        attr.value.data = {
                            estree: (_f = (_e = DEFAULT_PROP_EXPRESSIONS[attr.name]) === null || _e === void 0 ? void 0 : _e.estree) !== null && _f !== void 0 ? _f : objectEstree,
                        };
                        return attr;
                    }
                }
                return undefined;
            });
            node.attributes = newAttributes.filter((attr) => attr !== undefined);
        });
    };
}
