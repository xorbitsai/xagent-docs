import { visit } from 'unist-util-visit';
import { MetaOptions } from '../rehype/rehypeCodeBlocks/metaOptions.js';
const REACT_COMPONENT_NAME = 'Mermaid';
const RESERVED_KEYS = ['placement', 'actions'];
export const remarkMermaid = () => (tree) => {
    var _a;
    const codeblocks = [];
    visit(tree, 'code', (node, index, parent) => {
        if (node.lang === 'mermaid' && parent && typeof index === 'number') {
            codeblocks.push([node, index, parent]);
        }
    });
    if (codeblocks.length !== 0) {
        for (const [node, index, parent] of codeblocks) {
            const metaOptions = new MetaOptions((_a = node.meta) !== null && _a !== void 0 ? _a : '', RESERVED_KEYS);
            const placement = metaOptions.getString('placement');
            let actions = metaOptions.getBoolean('actions');
            if (actions === undefined) {
                const rangeValue = metaOptions.getRange('actions');
                if (rangeValue === 'true')
                    actions = true;
                else if (rangeValue === 'false')
                    actions = false;
            }
            const attributes = [
                {
                    type: 'mdxJsxAttribute',
                    name: 'chart',
                    value: {
                        type: 'mdxJsxAttributeValueExpression',
                        data: {
                            estree: {
                                body: [
                                    {
                                        type: 'ExpressionStatement',
                                        expression: {
                                            type: 'Literal',
                                            value: node.value,
                                            raw: JSON.stringify(node.value),
                                        },
                                    },
                                ],
                                type: 'Program',
                                sourceType: 'module',
                            },
                        },
                        value: node.value,
                    },
                },
            ];
            if (placement) {
                attributes.push({
                    type: 'mdxJsxAttribute',
                    name: 'placement',
                    value: placement,
                });
            }
            if (actions !== undefined) {
                attributes.push({
                    type: 'mdxJsxAttribute',
                    name: 'actions',
                    value: {
                        type: 'mdxJsxAttributeValueExpression',
                        data: {
                            estree: {
                                type: 'Program',
                                sourceType: 'module',
                                body: [
                                    {
                                        type: 'ExpressionStatement',
                                        expression: { type: 'Literal', value: actions, raw: String(actions) },
                                    },
                                ],
                            },
                        },
                        value: String(actions),
                    },
                });
            }
            parent.children.splice(index, 1, {
                type: 'mdxJsxFlowElement',
                name: REACT_COMPONENT_NAME,
                attributes,
                children: [],
            });
        }
    }
};
