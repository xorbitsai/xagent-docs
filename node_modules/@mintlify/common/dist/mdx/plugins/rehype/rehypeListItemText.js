import { visit } from 'unist-util-visit';
const ELEMENT_TYPES = ['element', 'mdxJsxFlowElement', 'mdxJsxTextElement'];
const MDX_EXPRESSION_TYPES = ['mdxFlowExpression', 'mdxTextExpression'];
const LIST_TAGS = ['ol', 'ul'];
const isElementNode = (node) => ELEMENT_TYPES.includes(node.type);
const isMdxExpression = (node) => MDX_EXPRESSION_TYPES.includes(node.type);
const getTagName = (node) => {
    if ('tagName' in node)
        return node.tagName;
    if ('name' in node)
        return node.name;
    return null;
};
const isListElement = (node) => {
    const tag = getTagName(node);
    return tag !== null && LIST_TAGS.includes(tag);
};
const isTextWithContent = (node) => { var _a; return node.type === 'text' && Boolean((_a = node.value) === null || _a === void 0 ? void 0 : _a.trim()); };
const addNoBulletAttribute = (node) => {
    if ('properties' in node) {
        node.properties['data-no-bullet'] = '';
        return;
    }
    node.attributes.push({
        type: 'mdxJsxAttribute',
        name: 'data-no-bullet',
        value: '',
    });
};
const hasOnlyNestedLists = (children) => {
    let foundList = false;
    for (const child of children) {
        if (isTextWithContent(child))
            return false;
        if (isMdxExpression(child))
            return false;
        if (!isElementNode(child))
            continue;
        if (isListElement(child)) {
            foundList = true;
            continue;
        }
        return false;
    }
    return foundList;
};
export const rehypeListItemText = () => (tree) => {
    visit(tree, (node) => {
        if (!isElementNode(node))
            return;
        if (getTagName(node) !== 'li')
            return;
        const element = node;
        if (element.children.length === 0)
            return;
        if (hasOnlyNestedLists(element.children)) {
            addNoBulletAttribute(element);
        }
    });
};
