import { findBestMatch } from './computeStringSimilarity.js';
import { findOriginalTextInContent } from './findTextInContent.js';
const DEFAULT_SIMILARITY_THRESHOLD = 0.85;
export function resolveAnchor(content, anchor, options) {
    var _a;
    const similarityThreshold = (_a = options === null || options === void 0 ? void 0 : options.similarityThreshold) !== null && _a !== void 0 ? _a : DEFAULT_SIMILARITY_THRESHOLD;
    if ((options === null || options === void 0 ? void 0 : options.currentCommit) && options.currentCommit === anchor.anchorCommit) {
        const lines = content.split('\n');
        let startIndex = 0;
        for (let i = 0; i < anchor.line - 1 && i < lines.length; i++) {
            startIndex += lines[i].length + 1;
        }
        startIndex += anchor.startCol;
        const endIndex = startIndex + anchor.originalText.length;
        if (content.slice(startIndex, endIndex) === anchor.originalText) {
            return {
                status: 'found',
                range: {
                    startIndex,
                    endIndex,
                },
            };
        }
    }
    const searchResult = findOriginalTextInContent(content, anchor);
    if (searchResult.found) {
        return {
            status: 'found',
            range: {
                startIndex: searchResult.startIndex,
                endIndex: searchResult.endIndex,
            },
        };
    }
    const fuzzyMatch = findBestMatch(content, anchor.originalText, {
        minSimilarity: similarityThreshold,
    });
    if (fuzzyMatch) {
        return {
            status: 'stale',
            range: {
                startIndex: fuzzyMatch.startIndex,
                endIndex: fuzzyMatch.endIndex,
            },
            similarity: fuzzyMatch.similarity,
        };
    }
    return {
        status: 'orphan',
        range: null,
    };
}
