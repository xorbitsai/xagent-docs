export function computeLevenshteinDistance(a, b) {
    if (a.length === 0)
        return b.length;
    if (b.length === 0)
        return a.length;
    const matrix = [];
    for (let i = 0; i <= b.length; i++) {
        matrix[i] = [i];
    }
    for (let j = 0; j <= a.length; j++) {
        matrix[0][j] = j;
    }
    for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            }
            else {
                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, matrix[i][j - 1] + 1, matrix[i - 1][j] + 1);
            }
        }
    }
    return matrix[b.length][a.length];
}
export function computeStringSimilarity(a, b) {
    if (a.length === 0 && b.length === 0)
        return 1;
    if (a.length === 0 || b.length === 0)
        return 0;
    const distance = computeLevenshteinDistance(a, b);
    const maxLength = Math.max(a.length, b.length);
    return 1 - distance / maxLength;
}
export function findBestMatch(content, target, options) {
    var _a, _b;
    const minSimilarity = (_a = options === null || options === void 0 ? void 0 : options.minSimilarity) !== null && _a !== void 0 ? _a : 0.85;
    const windowSize = (_b = options === null || options === void 0 ? void 0 : options.windowSize) !== null && _b !== void 0 ? _b : Math.ceil(target.length * 1.5);
    if (content.length === 0 || target.length === 0)
        return null;
    let bestMatch = null;
    const minLen = Math.ceil(target.length * 0.5);
    for (let i = 0; i <= content.length - minLen; i++) {
        for (let len = minLen; len <= Math.min(windowSize, content.length - i); len++) {
            const candidate = content.slice(i, i + len);
            const similarity = computeStringSimilarity(candidate, target);
            if (similarity >= minSimilarity && (!bestMatch || similarity > bestMatch.similarity)) {
                bestMatch = {
                    similarity,
                    startIndex: i,
                    endIndex: i + len,
                };
            }
        }
    }
    return bestMatch;
}
