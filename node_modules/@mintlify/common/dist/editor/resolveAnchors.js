import { resolveAnchor } from './resolveAnchor.js';
function computeLineAndCol(content, startIndex, endIndex) {
    const lines = content.split('\n');
    let charCount = 0;
    let line = 1;
    for (let i = 0; i < lines.length; i++) {
        const lineLength = lines[i].length + 1;
        if (charCount + lineLength > startIndex) {
            line = i + 1;
            break;
        }
        charCount += lineLength;
    }
    const startCol = startIndex - charCount;
    const lineContent = lines[line - 1] || '';
    const contextBeforeStart = Math.max(0, startCol - 50);
    const contextBefore = lineContent.slice(contextBeforeStart, startCol);
    let endCharCount = 0;
    let endLine = 1;
    for (let i = 0; i < lines.length; i++) {
        const lineLength = lines[i].length + 1;
        if (endCharCount + lineLength > endIndex) {
            endLine = i + 1;
            break;
        }
        endCharCount += lineLength;
    }
    const endCol = endIndex - endCharCount;
    const endLineContent = lines[endLine - 1] || '';
    const contextAfter = endLineContent.slice(endCol, endCol + 50);
    return { line, startCol, endCol, contextBefore, contextAfter };
}
export function resolveAnchors(content, threads, options) {
    return threads.map((thread) => {
        const resolution = resolveAnchor(content, thread.anchor, options);
        let updatedAnchor;
        if (resolution.range && resolution.status !== 'orphan') {
            const { line, startCol, endCol, contextBefore, contextAfter } = computeLineAndCol(content, resolution.range.startIndex, resolution.range.endIndex);
            const originalText = content.slice(resolution.range.startIndex, resolution.range.endIndex);
            const positionChanged = line !== thread.anchor.line ||
                startCol !== thread.anchor.startCol ||
                originalText !== thread.anchor.originalText;
            if (positionChanged) {
                updatedAnchor = Object.assign(Object.assign({}, thread.anchor), { line,
                    startCol,
                    endCol,
                    originalText,
                    contextBefore,
                    contextAfter, anchorCommit: (options === null || options === void 0 ? void 0 : options.currentCommit) || thread.anchor.anchorCommit });
            }
        }
        return {
            threadId: thread.threadId,
            resolution,
            updatedAnchor,
            metadata: thread.metadata,
        };
    });
}
