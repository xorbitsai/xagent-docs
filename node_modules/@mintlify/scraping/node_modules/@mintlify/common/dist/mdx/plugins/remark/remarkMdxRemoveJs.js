import { walk } from 'estree-walker';
import { remove } from 'unist-util-remove';
import { CONTINUE, visit } from 'unist-util-visit';
import { isMdxJsEsm } from '../../utils.js';
const objectEstree = {
    type: 'Program',
    body: [
        {
            type: 'ExpressionStatement',
            expression: {
                type: 'ObjectExpression',
                properties: [],
            },
        },
    ],
    sourceType: 'module',
    comments: [],
};
const arrayEstree = {
    type: 'Program',
    body: [
        {
            type: 'ExpressionStatement',
            expression: {
                type: 'ArrayExpression',
                elements: [],
            },
        },
    ],
    sourceType: 'module',
    comments: [],
};
const falseEstree = {
    type: 'Program',
    body: [
        {
            type: 'ExpressionStatement',
            expression: {
                type: 'Literal',
                value: false,
                raw: 'false',
            },
        },
    ],
    sourceType: 'module',
    comments: [],
};
const trueEstree = {
    type: 'Program',
    body: [
        {
            type: 'ExpressionStatement',
            expression: {
                type: 'Literal',
                value: true,
                raw: 'true',
            },
        },
    ],
    sourceType: 'module',
    comments: [],
};
function createStringEstree(str) {
    return {
        type: 'Program',
        body: [
            {
                type: 'ExpressionStatement',
                expression: {
                    type: 'Literal',
                    value: str,
                    raw: `'${str}'`,
                },
            },
        ],
        sourceType: 'module',
        comments: [],
    };
}
const numberEstree = {
    type: 'Program',
    body: [
        {
            type: 'ExpressionStatement',
            expression: {
                type: 'Literal',
                value: 1,
                raw: '1',
            },
        },
    ],
    sourceType: 'module',
    comments: [],
};
const DEFAULT_PROP_EXPRESSIONS = {
    placement: { value: '"bottom"', estree: createStringEstree('bottom') },
    deflectionEmail: { value: '""', estree: createStringEstree('') },
    searchSites: { value: '[]', estree: arrayEstree },
    spendLimit: { value: '1', estree: numberEstree },
    sampleQuestions: { value: '[]', estree: arrayEstree },
    slack: { value: 'false', estree: falseEstree },
    subdomain: { value: '""', estree: createStringEstree('') },
    context: { value: '{}', estree: objectEstree },
    title: { value: '""', estree: createStringEstree('') },
    description: { value: '""', estree: createStringEstree('') },
    icon: { value: '""', estree: createStringEstree('') },
    href: { value: '""', estree: createStringEstree('') },
    iconType: { value: '"regular"', estree: createStringEstree('regular') },
    enabled: { value: '"false"', estree: createStringEstree('false') },
    name: { value: '""', estree: createStringEstree('') },
    mcp: { value: '{}', estree: objectEstree },
    openapi: { value: '""', estree: createStringEstree('') },
    servers: { value: '[]', estree: arrayEstree },
    securitySchemes: { value: '{}', estree: objectEstree },
    security: { value: '{}', estree: objectEstree },
    authMethod: { value: '"bearer"', estree: createStringEstree('bearer') },
    playground: { value: '"interactive"', estree: createStringEstree('interactive') },
    server: { value: '""', estree: createStringEstree('') },
    metadata: { value: '{}', estree: objectEstree },
    content: { value: '""', estree: createStringEstree('') },
    codeSamples: { value: '[]', estree: arrayEstree },
    lang: { value: '""', estree: createStringEstree('') },
    label: { value: '""', estree: createStringEstree('') },
    source: { value: '""', estree: createStringEstree('') },
    examples: { value: '{}', estree: objectEstree },
    summary: { value: '""', estree: createStringEstree('') },
    value: { value: '{}', estree: objectEstree },
    contextual: { value: '{ "options": [] }', estree: falseEstree },
    api: { value: '{}', estree: objectEstree },
    navigation: { value: '{}', estree: objectEstree },
    asyncapi: { value: '""', estree: createStringEstree('') },
    directory: { value: '""', estree: createStringEstree('') },
    'x-hidden': { value: '"true"', estree: trueEstree },
    'x-excluded': { value: '"true"', estree: trueEstree },
};
const REACT_HOOKS = [
    'useState',
    'useEffect',
    'useRef',
    'useCallback',
    'useMemo',
    'useReducer',
    'useContext',
    'useLayoutEffect',
    'useImperativeHandle',
    'useDebugValue',
    'useDeferredValue',
    'useTransition',
    'useId',
    'useSyncExternalStore',
    'useInsertionEffect',
    'useOptimistic',
    'useActionState',
];
export function isStringSafe(value) {
    switch (true) {
        case value === 'true':
        case value === 'false':
        // purely alphanumeric string
        case /^[_a-zA-Z0-9]+$/.test(value):
        // string literal with quotes
        case /^'[_a-zA-Z0-9\s`".\-\\{}\?\(\)&*^%#@!~=+\[\]|:;,\/]+'$/.test(value):
        case /^"[_a-zA-Z0-9\s`'.\-\\{}\?\(\)&*^%#@!~=+\[\]|:;,\/]+"$/.test(value):
        case /^`[_a-zA-Z0-9\s'".\-\\{}\?\(\)&*^%#@!~=+\[\]|:;,\/]+`$/.test(value):
        // purely alphanumeric string prefixed with `!!`
        case /^!![_a-zA-Z0-9]+$/.test(value):
        // purely alphanumeric string wrapped in parens
        case /^\([_a-zA-Z0-9]+\)$/.test(value):
        // purely alphanumeric string prefixed with `!!` wrapped in parens
        case /^\(!![_a-zA-Z0-9]+\)$/.test(value):
            return true;
        // could contain arbitrary javascript
        default:
            return false;
    }
}
export const remarkMdxRemoveJs = () => (tree) => {
    remove(tree, ['mdxTextExpression', 'mdxFlowExpression']);
    remove(tree, (node) => {
        var _a;
        if (!isMdxJsEsm(node))
            return false;
        if (((_a = node.data) === null || _a === void 0 ? void 0 : _a.estree) && !isFunction(node.data.estree))
            return false;
        const value = node.value;
        const containsReact = REACT_HOOKS.some((hook) => value.includes(hook) || value.includes('React.' + hook.toLowerCase()));
        return containsReact;
    });
    visit(tree, (node) => {
        if (!('attributes' in node))
            return CONTINUE;
        const newAttributes = node.attributes.map((attr) => {
            var _a, _b, _c, _d;
            if (attr.type === 'mdxJsxAttribute' && !(attr.value instanceof Object))
                return attr;
            if (typeof attr.value === 'string' && isStringSafe(attr.value))
                return attr;
            if (attr.type === 'mdxJsxAttribute' && attr.value instanceof Object) {
                if (isStringSafe(attr.value.value))
                    return attr;
                if (Object.keys(DEFAULT_PROP_EXPRESSIONS).includes(attr.name)) {
                    attr.value.value = (_b = (_a = DEFAULT_PROP_EXPRESSIONS[attr.name]) === null || _a === void 0 ? void 0 : _a.value) !== null && _b !== void 0 ? _b : '{}';
                    attr.value.data = { estree: (_d = (_c = DEFAULT_PROP_EXPRESSIONS[attr.name]) === null || _c === void 0 ? void 0 : _c.estree) !== null && _d !== void 0 ? _d : objectEstree };
                    return attr;
                }
            }
            return undefined;
        });
        node.attributes = newAttributes.filter((attr) => attr !== undefined);
    });
};
function isFunction(estree) {
    if (!estree.body.length)
        return false;
    let hasFunctionDeclaration = false;
    walk(estree, {
        enter(node) {
            if (node.type === 'FunctionDeclaration' ||
                node.type === 'ArrowFunctionExpression' ||
                node.type === 'FunctionExpression') {
                hasFunctionDeclaration = true;
                return this.skip();
            }
            if (node.type === 'ExportDefaultDeclaration' &&
                (node.declaration.type === 'FunctionDeclaration' ||
                    node.declaration.type === 'FunctionExpression' ||
                    node.declaration.type === 'ArrowFunctionExpression')) {
                hasFunctionDeclaration = true;
                return this.skip();
            }
            if (node.type === 'VariableDeclaration' &&
                node.declarations.some((decl) => decl.init &&
                    (decl.init.type === 'ArrowFunctionExpression' ||
                        decl.init.type === 'FunctionExpression'))) {
                hasFunctionDeclaration = true;
                return this.skip();
            }
        },
    });
    return hasFunctionDeclaration;
}
