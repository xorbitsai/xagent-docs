var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { serialize } from '@mintlify/mdx/server';
import { getTailwindSelectors } from '../../css/tailwind.js';
import { getMDXOptions, remarkMdxRemoveJs, remarkExpandContent, remarkSplitCodeGroup, remarkSplitTabs, remarkValidateSteps, remarkValidateTabs, } from '../../index.js';
import { codeStylingToThemeOrThemes } from '../getCodeStyling.js';
import { createSnippetTreeMap } from './getMdx/snippets.js';
export function getMdx(_a) {
    return __awaiter(this, arguments, void 0, function* ({ path, content, metadata, snippets, subdomain, codeStyling, config, tailwindSelectors = undefined, pageType = 'default', trace = undefined, customLanguages = [], }) {
        const traceFn = trace !== null && trace !== void 0 ? trace : ((_name, fn) => fn());
        if (!tailwindSelectors)
            tailwindSelectors = yield traceFn('getMdx.getTailwindSelectors', () => __awaiter(this, void 0, void 0, function* () { return getTailwindSelectors({ content }); }));
        const snippetTreeMap = yield traceFn('getMdx.createSnippetTreeMap', () => __awaiter(this, void 0, void 0, function* () { return createSnippetTreeMap(snippets); }));
        const mdxOptionsData = {
            subdomain,
            snippetTreeMap,
            pageMetadata: metadata,
            config,
            codeStyling,
            tailwindSelectors,
        };
        let mdxExtracts = {};
        let plugins = [remarkValidateSteps, remarkValidateTabs];
        if (pageType === 'pdf') {
            plugins = [...plugins, remarkExpandContent, remarkSplitCodeGroup, remarkSplitTabs];
        }
        const mdxOptions = getMDXOptions({ data: mdxOptionsData, remarkPlugins: plugins, mdxExtracts });
        const mdxOptionsNoJs = getMDXOptions({
            data: mdxOptionsData,
            remarkPlugins: [remarkMdxRemoveJs, ...plugins],
        });
        const scope = {
            codeStyling,
            config,
            pageMetadata: metadata,
        };
        const { mdxSource, mdxSourceWithNoJs } = yield traceFn('getMdx.compileMdx.mainContent', () => __awaiter(this, void 0, void 0, function* () {
            return compileMdx({
                content,
                scope,
                mdxOptions,
                mdxOptionsNoJs,
                codeStyling,
                path,
                traceFn,
                customLanguages,
            });
        }));
        const originalMdxExtracts = structuredClone(mdxExtracts);
        let panelMdxSource;
        let panelMdxSourceWithNoJs;
        if (mdxExtracts.panel && mdxExtracts.panel.content) {
            const panelContent = mdxExtracts.panel.content;
            const compiledMdx = yield traceFn('getMdx.compileMdx.panelContent', () => __awaiter(this, void 0, void 0, function* () {
                return compileMdx({
                    content: panelContent,
                    scope,
                    mdxOptions,
                    mdxOptionsNoJs,
                    codeStyling,
                    path,
                    traceFn,
                    customLanguages,
                });
            }));
            panelMdxSource = compiledMdx.mdxSource;
            panelMdxSourceWithNoJs = compiledMdx.mdxSourceWithNoJs;
            // serializing mdx content with the panel content will remove the original mdxExtracts
            // so we need to restore the original mdxExtracts
            mdxExtracts = Object.assign(Object.assign({}, originalMdxExtracts), { codeExamples: mdxExtracts.codeExamples });
        }
        // to avoid flash on initial load, we set the first view as active
        if (mdxExtracts.multiViewItems) {
            mdxExtracts.multiViewItems = mdxExtracts.multiViewItems.map((item, index) => (Object.assign(Object.assign({}, item), { active: index === 0 })));
        }
        return {
            mdxExtracts,
            mdxSource,
            mdxSourceWithNoJs,
            panelMdxSource,
            panelMdxSourceWithNoJs,
        };
    });
}
function compileMdx(_a) {
    return __awaiter(this, arguments, void 0, function* ({ content, scope, mdxOptions, mdxOptionsNoJs, codeStyling, path, traceFn, customLanguages, }) {
        const mdxSource = yield traceFn('compileMdx.withJs', () => __awaiter(this, void 0, void 0, function* () {
            return getCompiledMdxWithFallback({
                source: content,
                scope,
                mdxOptions,
                codeStyling,
                path,
                traceFn,
                customLanguages,
            });
        }));
        const mdxSourceWithNoJs = yield traceFn('compileMdx.withoutJs', () => __awaiter(this, void 0, void 0, function* () {
            return getCompiledMdxWithFallback({
                source: content,
                scope,
                mdxOptions: mdxOptionsNoJs,
                codeStyling,
                path,
                traceFn,
                customLanguages,
            });
        }));
        return { mdxSource, mdxSourceWithNoJs };
    });
}
function getCompiledMdxWithFallback(_a) {
    return __awaiter(this, arguments, void 0, function* ({ source, scope, mdxOptions, codeStyling, path, traceFn, customLanguages, }) {
        const themeOrThemes = codeStylingToThemeOrThemes(codeStyling);
        try {
            const result = yield traceFn('getCompiledMdxWithFallback.serialize', () => __awaiter(this, void 0, void 0, function* () {
                return serialize({
                    source,
                    scope,
                    mdxOptions,
                    syntaxHighlightingOptions: Object.assign(Object.assign({}, themeOrThemes), { customLanguages }),
                });
            }));
            if ('error' in result) {
                throw result.error;
            }
            result.scope = Object.assign(Object.assign({}, result.scope), { config: {} });
            return result;
        }
        catch (err) {
            if (path)
                console.log(`âš ï¸ Warning: MDX failed to parse page ${path}: `, err);
            // placeholder content for when there is a syntax error.
            const fallbackResult = yield traceFn('getCompiledMdxWithFallback.serialize.fallback', () => __awaiter(this, void 0, void 0, function* () {
                return serialize({
                    source: 'ðŸš§ A parsing error occured. Please contact the owner of this website. They can use the Mintlify CLI to test this website locally and see the errors that occur.',
                    scope,
                    mdxOptions,
                    syntaxHighlightingOptions: Object.assign(Object.assign({}, themeOrThemes), { customLanguages }),
                });
            }));
            if ('error' in fallbackResult) {
                throw fallbackResult.error;
            }
            fallbackResult.scope = Object.assign(Object.assign({}, fallbackResult.scope), { config: {} });
            return fallbackResult;
        }
    });
}
export { createSnippetTreeMap };
