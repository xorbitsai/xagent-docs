import { parse } from 'path';
import { SNIPPET_EXTENSIONS } from './mdx/snippets/constants.js';
import { isImportedAsSnippet } from './mdx/snippets/isImportedAsSnippet.js';
import { optionallyRemoveLeadingSlash } from './optionallyRemoveLeadingSlash.js';
const excludedMdFiles = ['readme', 'license', 'contributing', 'contribute'];
export const generatedStaticFiles = [
    'llms.txt',
    'robots.txt',
    'sitemap.xml',
    'llms-full.txt',
];
export const IMAGE_FORMATS = [
    '.jpeg',
    '.jpg',
    '.jfif',
    '.pjpeg',
    '.pjp',
    '.png',
    '.svg',
    '.svgz',
    '.ico',
    '.webp',
    '.gif',
    '.apng',
    '.avif',
    '.bmp',
    '.tiff',
    '.tif',
];
export const VIDEO_FORMATS = [
    '.mp4',
    '.webm',
    '.ogg',
    '.avi',
    '.mov',
    '.wmv',
    '.flv',
    '.mkv',
    '.m4v',
];
export const AUDIO_FORMATS = ['.mp3', '.wav', '.flac', '.aac', '.ogg', '.wma', '.m4a'];
export const DOCUMENT_FORMATS = [
    '.pdf',
    '.txt',
    '.doc',
    '.docx',
    '.xls',
    '.xlsx',
    '.ppt',
    '.pptx',
    '.rtf',
    '.odt',
    '.ods',
    '.odp',
];
export const DATA_FORMATS = ['.csv', '.tsv', '.xml'];
export const FONT_FORMATS = ['.woff', '.woff2', '.ttf', '.eot', '.otf'];
export const COMPRESSED_FORMATS = ['.zip', '.rar', '.7z', '.tar', '.gz', '.bz2'];
const supportedStaticFileExtensions = [
    ...IMAGE_FORMATS,
    ...VIDEO_FORMATS,
    ...AUDIO_FORMATS,
    ...DOCUMENT_FORMATS,
    ...DATA_FORMATS,
    ...FONT_FORMATS,
    ...COMPRESSED_FORMATS,
];
const gatedStaticAssetExtensions = [...DOCUMENT_FORMATS, ...DATA_FORMATS, ...COMPRESSED_FORMATS];
export function isGatedFormat({ filePath, ext }) {
    if (ext == undefined) {
        ext = filePath.split('.').at(-1);
        if (!ext)
            return false;
    }
    ext = ext.startsWith('.') ? ext : `.${ext}`;
    return gatedStaticAssetExtensions.includes(ext.toLowerCase());
}
export const getFileCategory = (filePath, options) => {
    const normalizedFilePath = optionallyRemoveLeadingSlash(filePath.toLowerCase());
    const parsed = parse(normalizedFilePath);
    if (parsed.base === 'mint.json') {
        return 'mintConfig';
    }
    if (parsed.base === 'docs.json') {
        return 'docsConfig';
    }
    if (parsed.base === '.mintignore') {
        return 'mintIgnore';
    }
    const fileName = parsed.name;
    const extension = parsed.ext;
    if (generatedStaticFiles.includes(parsed.base)) {
        return 'generatedStaticFile';
    }
    if ((normalizedFilePath.startsWith('_snippets/') || normalizedFilePath.startsWith('snippets/')) &&
        SNIPPET_EXTENSIONS.some((ext) => extension === ext)) {
        if (normalizedFilePath.startsWith('_snippets/')) {
            return 'snippet';
        }
        else if (normalizedFilePath.startsWith('snippets/')) {
            return 'snippet-v2';
        }
    }
    else if (extension === '.mdx') {
        if ((options === null || options === void 0 ? void 0 : options.importedFiles) != null && isImportedAsSnippet(filePath, options.importedFiles)) {
            return 'snippet-v2';
        }
        return 'page';
    }
    else if (extension === '.md') {
        // Exclude common markdown files people don't want on their docs website
        if (excludedMdFiles.includes(fileName)) {
            return null;
        }
        if ((options === null || options === void 0 ? void 0 : options.importedFiles) != null && isImportedAsSnippet(filePath, options.importedFiles)) {
            return 'snippet-v2';
        }
        return 'page';
    }
    else if (extension === '.jsx') {
        return 'snippet-v2';
    }
    else if (extension === '.yaml' || extension === '.yml') {
        return 'potentialYamlOpenApiSpec';
    }
    else if (extension === '.json') {
        return 'potentialJsonOpenApiSpec';
    }
    else if (extension === '.css') {
        return 'css';
    }
    else if (extension === '.js') {
        return 'js';
    }
    else if (supportedStaticFileExtensions.includes(extension)) {
        return 'staticFile';
    }
    return null;
};
