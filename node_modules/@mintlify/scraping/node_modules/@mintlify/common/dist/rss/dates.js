export const getDateForNode = (node, lineBlame) => {
    if (!node.position) {
        return new Date().toISOString();
    }
    const startLine = node.position.start.line;
    const blameDate = lineBlame[startLine];
    if (blameDate) {
        const parsedDate = new Date(blameDate);
        if (!isNaN(parsedDate.getTime())) {
            return parsedDate.toISOString();
        }
    }
    return new Date().toISOString();
};
export const getMostRepresentativeDate = (updateComponent, lineBlame, defaultDate) => {
    const dates = [];
    const collectDates = (nodes) => {
        for (const node of nodes) {
            if (node.type !== 'heading' && node.position) {
                const nodeDate = getDateForNode(node, lineBlame);
                dates.push(nodeDate);
            }
            if ('children' in node && Array.isArray(node.children) && node.children.length > 0) {
                collectDates(node.children);
            }
        }
    };
    collectDates(updateComponent.children);
    if (dates.length === 0) {
        return defaultDate;
    }
    const dateCounts = new Map();
    for (const date of dates) {
        dateCounts.set(date, (dateCounts.get(date) || 0) + 1);
    }
    let mostCommonDate = defaultDate;
    let maxCount = 0;
    for (const [date, count] of dateCounts.entries()) {
        if (count > maxCount) {
            maxCount = count;
            mostCommonDate = date;
        }
    }
    const threshold = dates.length * 0.9;
    if (maxCount >= threshold) {
        return mostCommonDate;
    }
    return defaultDate;
};
