import { divisions } from '@mintlify/validation';
import { isPage } from '../navigation/isPage.js';
import { optionallyRemoveLeadingSlash } from '../optionallyRemoveLeadingSlash.js';
/**
 * Generates a map from page paths to their hidden status based on navigation hierarchy.
 * A page is hidden if:
 * - It has noindex: true in its frontmatter, OR
 * - Any parent group/division has hidden: true
 * Assumes page hrefs in navWithPageContext have a leading / but config page paths do not.
 * Outputted dictionary will NOT have a leading / in the dictionary keys.
 */
export function generatePathToHiddenDict(decoratedNav) {
    const pathToHiddenDict = new Map();
    generatePathToHiddenDictRecursive(pathToHiddenDict, decoratedNav, false);
    return pathToHiddenDict;
}
function generatePathToHiddenDictRecursive(pathToHiddenDict, nav, parentHidden) {
    if (typeof nav !== 'object')
        return;
    // Determine the effective hidden status for this level (from group/tab hidden property)
    const effectiveHidden = 'hidden' in nav && typeof nav.hidden === 'boolean' ? nav.hidden : parentHidden;
    if (isPage(nav)) {
        const key = optionallyRemoveLeadingSlash(nav.href);
        // A page is hidden if parent has hidden: true OR page has noindex: true in frontmatter
        const pageNoindex = 'noindex' in nav && nav.noindex === true;
        const isHidden = effectiveHidden || pageNoindex;
        // Only add hidden pages to the dictionary (more efficient)
        // We keep the first value encountered to handle duplicate paths
        if (isHidden && !pathToHiddenDict.has(key)) {
            pathToHiddenDict.set(key, true);
        }
    }
    if ('pages' in nav) {
        if ('root' in nav && typeof nav.root === 'object') {
            generatePathToHiddenDictRecursive(pathToHiddenDict, nav.root, effectiveHidden);
        }
        for (const page of nav.pages) {
            if (typeof page === 'object') {
                generatePathToHiddenDictRecursive(pathToHiddenDict, page, effectiveHidden);
            }
        }
    }
    for (const key of ['groups', ...divisions]) {
        if (key in nav) {
            const items = nav[key];
            if (Array.isArray(items)) {
                for (const item of items) {
                    generatePathToHiddenDictRecursive(pathToHiddenDict, item, effectiveHidden);
                }
            }
        }
    }
}
