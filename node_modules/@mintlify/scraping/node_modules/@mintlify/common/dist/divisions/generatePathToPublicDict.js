import { divisions } from '@mintlify/validation';
import { isPage } from '../navigation/isPage.js';
import { optionallyRemoveLeadingSlash } from '../optionallyRemoveLeadingSlash.js';
/**
 * Generates a map from page paths to their public status based on navigation hierarchy.
 * A page is public if it or any parent group/division has public: true.
 * Assumes page hrefs in navWithPageContext have a leading / but config page paths do not.
 * Outputted dictionary will NOT have a leading / in the dictionary keys.
 * @param rootPublic - The default public status for pages not explicitly set in navigation
 */
export function generatePathToPublicDict(decoratedNav, rootPublic) {
    const pathToPublicDict = new Map();
    generatePathToPublicDictRecursive(pathToPublicDict, decoratedNav, rootPublic !== null && rootPublic !== void 0 ? rootPublic : false);
    return pathToPublicDict;
}
function generatePathToPublicDictRecursive(pathToPublicDict, nav, parentPublic) {
    if (typeof nav !== 'object')
        return;
    // Determine the effective public status for this level
    const effectivePublic = 'public' in nav && typeof nav.public === 'boolean' ? nav.public : parentPublic;
    if (isPage(nav)) {
        const key = optionallyRemoveLeadingSlash(nav.href);
        // Set the public status for this page if not already set
        // We keep the first value encountered to handle duplicate paths
        if (!pathToPublicDict.has(key)) {
            pathToPublicDict.set(key, effectivePublic);
        }
    }
    if ('pages' in nav) {
        if ('root' in nav && typeof nav.root === 'object') {
            generatePathToPublicDictRecursive(pathToPublicDict, nav.root, effectivePublic);
        }
        for (const page of nav.pages) {
            if (typeof page === 'object') {
                generatePathToPublicDictRecursive(pathToPublicDict, page, effectivePublic);
            }
        }
    }
    for (const key of ['groups', ...divisions]) {
        if (key in nav) {
            const items = nav[key];
            if (Array.isArray(items)) {
                for (const item of items) {
                    generatePathToPublicDictRecursive(pathToPublicDict, item, effectivePublic);
                }
            }
        }
    }
}
