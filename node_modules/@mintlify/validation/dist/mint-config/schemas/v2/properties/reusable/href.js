import { z } from 'zod';
const ALLOWED_PROTOCOLS = ['https:'];
const DANGEROUS_FILE_EXTENSIONS = ['.svg', '.exe', '.zip'];
// Normalizes a URL by removing trailing slashes and anchor links
export function normalizeUrl(value) {
    let normalized = value;
    const hashIndex = normalized.indexOf('#');
    if (hashIndex !== -1) {
        normalized = normalized.substring(0, hashIndex);
    }
    try {
        const url = new URL(normalized);
        if (url.pathname !== '/' && url.pathname.endsWith('/')) {
            url.pathname = url.pathname.replace(/\/+$/, '');
            normalized = url.toString();
        }
    }
    catch (_a) {
        // Handle relative paths that can't be parsed by URL constructor
        if (!normalized.startsWith('mailto:')) {
            // Split on query parameter to handle paths with query strings
            const queryIndex = normalized.indexOf('?');
            if (queryIndex !== -1) {
                const pathPart = normalized.substring(0, queryIndex);
                const queryPart = normalized.substring(queryIndex);
                // Remove trailing slashes from path part (but preserve single slash)
                const normalizedPath = pathPart.length > 1 && pathPart.endsWith('/') ? pathPart.replace(/\/+$/, '') : pathPart;
                normalized = normalizedPath + queryPart;
            }
            else {
                // No query params, just check for trailing slash
                if (normalized.length > 1 && normalized.endsWith('/')) {
                    normalized = normalized.replace(/\/+$/, '');
                }
            }
        }
    }
    return normalized;
}
export const hrefSchema = z
    .string()
    .refine((value) => {
    // Allow relative paths starting with /
    if (value.startsWith('/'))
        return true;
    // Allow mailto links
    if (value.startsWith('mailto:'))
        return true;
    // Allow absolute URLs
    try {
        new URL(value);
        return true;
    }
    catch (_a) {
        return false;
    }
}, { message: 'Must be a valid URL or relative path' })
    .describe('A valid path or external link');
/**
 * Allows relative paths, mailto, and secure absolute URLs (https), while blocking
 * dangerous file extensions.
 */
export const secureHrefSchema = z
    .string()
    .transform(normalizeUrl)
    .refine((value) => {
    if (value.startsWith('//'))
        return false;
    if (value.startsWith('/'))
        return true;
    if (value.startsWith('mailto:'))
        return true;
    try {
        const url = new URL(value);
        const isAllowedProtocol = ALLOWED_PROTOCOLS.includes(url.protocol);
        const decodedPathname = decodeURIComponent(url.pathname).toLowerCase();
        const isSafeExtension = !DANGEROUS_FILE_EXTENSIONS.some((ext) => decodedPathname.endsWith(ext));
        return isAllowedProtocol && isSafeExtension;
    }
    catch (_a) {
        return false;
    }
}, { message: 'Must be a valid url or relative path.' });
